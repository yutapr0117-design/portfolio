<!--
本ファイルは、作りながら学ぶための実験的SPAポートフォリオです。

目的:
- 最小構成でのSPA設計検証
- 実装より設計判断を重視
- 完成品ではなく、進化前提の実験場

補足:
- 構造・設計はすべて意図的です
- 将来的な破壊的変更を前提としています
-->

<!doctype html>
<html lang="ja" data-theme="system">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Portfolio</title>
    <meta name="description" content="謙虚なITエンジニアのポートフォリオ。内蔵アプリ、増分インポート、整合性チェック/自動修復、セマンティックHTML5対応。" />

    <!-- SEO Meta Tags -->
    <meta name="robots" content="index, follow" />
    <meta name="author" content="ユウタ" />
    <meta name="theme-color" content="#2563eb" />

    <!-- Open Graph -->
    <meta property="og:title" content="Portfolio | 謙虚なITエンジニア" />
    <meta property="og:description" content="ポートフォリオ。内蔵アプリ、整合性チェック/自動修復、セマンティックHTML5対応。" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://example.com" />
    <meta property="og:image" content="https://example.com/og-image.png" />
    <meta property="og:site_name" content="Portfolio" />

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Portfolio | 謙虚なITエンジニア" />
    <meta name="twitter:description" content="ポートフォリオ。内蔵アプリ、整合性チェック/自動修復。" />

    <!-- Preconnect for performance -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="dns-prefetch" href="https://fonts.googleapis.com" />

    <!-- Canonical URL -->
    <link rel="canonical" href="https://example.com" />

    <!-- JSON-LD Structured Data -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "Person",
        "name": "ユウタ",
        "jobTitle": "ITエンジニア",
        "description": "謙虚なITエンジニアのポートフォリオ",
        "email": "yuta.pr.0117@gmail.com",
        "url": "https://example.com",
        "sameAs": []
    }
    </script>

    <!-- JSON-LD WebSite -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "WebSite",
        "name": "Portfolio",
        "url": "https://example.com",
        "potentialAction": {
            "@type": "SearchAction",
            "target": "https://example.com/#/projects?q={search_term_string}",
            "query-input": "required name=search_term_string"
        }
    }
    </script>

    
    <style>
        /* ===== CSS Custom Properties - Design System ===== */
        :root {
            /* Colors - Refined for better visual comfort and accessibility */
            --color-primary-rgb: 37, 99, 235;
            --color-primary: rgb(var(--color-primary-rgb));
            --color-primary-light: #60a5fa;
            --color-primary-dark: #1d4ed8;

            --color-success-rgb: 22, 163, 74;
            --color-success: rgb(var(--color-success-rgb));
            --color-warning-rgb: 217, 119, 6;
            --color-warning: rgb(var(--color-warning-rgb));
            --color-danger-rgb: 220, 38, 38;
            --color-danger: rgb(var(--color-danger-rgb));
            --color-info-rgb: 8, 145, 178;
            --color-info: rgb(var(--color-info-rgb));

            /* Light Theme - Softer colors for reduced eye strain */
            --bg-body: #f8fafc;
            --bg-secondary: #ffffff;
            --bg-tertiary: #f1f5f9;
            --surface: #ffffff;
            --surface-hover: #f1f5f9;

            --text-primary: #0f172a;
            --text-secondary: #334155;
            --text-tertiary: #64748b;
            --text-muted: #94a3b8;

            --border-color: #e2e8f0;
            --border-color-strong: #cbd5e1;

            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            --shadow-md: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            --shadow-lg: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            --shadow-xl: 0 25px 50px -12px rgba(0, 0, 0, 0.25);

            --focus-ring: 0 0 0 3px rgba(var(--color-primary-rgb), 0.2);
            --focus-ring-danger: 0 0 0 3px rgba(var(--color-danger-rgb), 0.2);

            /* Typography - Optimized for Japanese readability */
            --font-sans: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Hiragino Sans", "Hiragino Kaku Gothic ProN", "Meiryo", sans-serif;
            --font-mono: 'JetBrains Mono', ui-monospace, SFMono-Regular, "SF Mono", Consolas, "Liberation Mono", Menlo, Monaco, monospace;

            /* Spacing Scale */
            --space-1: 0.25rem;
            --space-2: 0.5rem;
            --space-3: 0.75rem;
            --space-4: 1rem;
            --space-5: 1.25rem;
            --space-6: 1.5rem;
            --space-8: 2rem;
            --space-10: 2.5rem;
            --space-12: 3rem;
            --space-16: 4rem;
            --space-20: 5rem;

            /* Border Radius - More modern rounded corners */
            --radius-sm: 0.375rem;
            --radius: 0.625rem;
            --radius-md: 0.875rem;
            --radius-lg: 1.25rem;
            --radius-xl: 1.5rem;
            --radius-2xl: 2rem;
            --radius-full: 9999px;

            /* Transitions */
            --transition-fast: 100ms cubic-bezier(0.4, 0, 0.2, 1);
            --transition: 200ms cubic-bezier(0.4, 0, 0.2, 1);
            --transition-slow: 300ms cubic-bezier(0.4, 0, 0.2, 1);

            /* Z-index Scale */
            --z-dropdown: 1000;
            --z-sticky: 1020;
            --z-fixed: 1030;
            --z-modal-backdrop: 1040;
            --z-modal: 1050;
            --z-popover: 1060;
            --z-tooltip: 1070;
            --z-toast: 1080;
        }

        /* Dark Theme - High contrast and comfort */
        [data-theme="dark"] {
            --bg-body: #020617;
            --bg-secondary: #0f172a;
            --bg-tertiary: #1e293b;
            --surface: #1e293b;
            --surface-hover: #334155;

            --text-primary: #f8fafc;
            --text-secondary: #cbd5e1;
            --text-tertiary: #94a3b8;
            --text-muted: #64748b;

            --border-color: #334155;
            --border-color-strong: #475569;

            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.3);
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5);
            --shadow-md: 0 10px 15px -3px rgba(0, 0, 0, 0.6);
            --shadow-lg: 0 20px 25px -5px rgba(0, 0, 0, 0.7);
            --shadow-xl: 0 25px 50px -12px rgba(0, 0, 0, 0.8);

            --color-primary: #60a5fa;
            --color-primary-light: #93c5fd;
            --color-primary-dark: #3b82f6;
        }

        /* System preference detection */
        @media (prefers-color-scheme: dark) {
            [data-theme="system"] {
                --bg-body: #020617;
                --bg-secondary: #0f172a;
                --bg-tertiary: #1e293b;
                --surface: #1e293b;
                --surface-hover: #334155;

                --text-primary: #f8fafc;
                --text-secondary: #cbd5e1;
                --text-tertiary: #94a3b8;
                --text-muted: #64748b;

                --border-color: #334155;
                --border-color-strong: #475569;

                --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.3);
                --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5);
                --shadow-md: 0 10px 15px -3px rgba(0, 0, 0, 0.6);
                --shadow-lg: 0 20px 25px -5px rgba(0, 0, 0, 0.7);
                --shadow-xl: 0 25px 50px -12px rgba(0, 0, 0, 0.8);

                --color-primary: #60a5fa;
                --color-primary-light: #93c5fd;
                --color-primary-dark: #3b82f6;
            }
        }

        /* ===== Reset & Base ===== */
        *,
        *::before,
        *::after {
            box-sizing: border-box;
        }

        * {
            margin: 0;
            padding: 0;
        }

        html {
            scroll-behavior: smooth;
            -webkit-text-size-adjust: 100%;
            tab-size: 4;
        }

        body {
            font-family: var(--font-sans);
            background-color: var(--bg-body);
            color: var(--text-primary);
            line-height: 1.75; /* Improved for readability */
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            min-height: 100vh;
            letter-spacing: 0.01em;
        }

        h1, h2, h3, h4, h5, h6 {
            line-height: 1.2;
            letter-spacing: -0.02em;
            font-weight: 700;
        }

        img,
        picture,
        video,
        canvas,
        svg {
            display: block;
            max-width: 100%;
        }

        input,
        button,
        textarea,
        select {
            font: inherit;
            color: inherit;
        }

        button {
            cursor: pointer;
            background: none;
            border: none;
        }

        a {
            color: inherit;
            text-decoration: none;
            transition: color var(--transition-fast);
        }

        ul,
        ol {
            list-style: none;
        }

        /* ===== Accessibility ===== */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }

        .skip-link {
            position: absolute;
            top: -100%;
            left: var(--space-4);
            z-index: var(--z-tooltip);
            padding: var(--space-3) var(--space-4);
            background: var(--surface);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            box-shadow: var(--shadow-lg);
            font-weight: 600;
            transition: top var(--transition-fast);
        }

        .skip-link:focus {
            top: var(--space-4);
            outline: none;
            box-shadow: var(--focus-ring);
        }

        /* Focus Visible */
        :focus {
            outline: none;
        }

        :focus-visible {
            outline: none;
            box-shadow: var(--focus-ring);
        }

        /* ===== Layout ===== */
        .app {
            display: flex;
            min-height: 100vh;
        }

        /* Header / Topbar */
        .topbar {
            display: none;
            position: sticky;
            top: 0;
            z-index: var(--z-sticky);
            background: rgba(var(--color-primary-rgb), 0.05);
            backdrop-filter: blur(12px);
            border-bottom: 1px solid var(--border-color);
            padding: var(--space-3) var(--space-4);
            align-items: center;
            gap: var(--space-3);
        }

        .brand {
            font-weight: 800;
            font-size: 1.25rem;
            letter-spacing: -0.04em;
            background: linear-gradient(135deg, var(--color-primary), var(--color-primary-light));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        /* Sidebar */
        .sidebar {
            width: 280px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            padding: var(--space-8) var(--space-4);
            position: sticky;
            top: 0;
            height: 100vh;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--border-color) transparent;
        }

        .sidebar::-webkit-scrollbar {
            width: 4px;
        }

        .sidebar::-webkit-scrollbar-track {
            background: transparent;
        }

        .sidebar::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: var(--radius-full);
        }

        /* Main Content */
        .main-content {
            flex: 1;
            min-width: 0;
            padding: var(--space-10) var(--space-10) var(--space-20);
            max-width: 1200px;
            margin: 0 auto;
        }

        /* Mobile Navigation */
        .overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.4);
            z-index: var(--z-modal-backdrop);
            backdrop-filter: blur(8px);
        }

        .drawer {
            display: none;
            position: fixed;
            inset: 0 auto 0 0;
            width: min(85vw, 320px);
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            z-index: var(--z-modal);
            padding: var(--space-6) var(--space-4);
            overflow-y: auto;
            box-shadow: var(--shadow-xl);
        }

        /* Responsive */
        @media (max-width: 920px) {
            .sidebar {
                display: none;
            }

            .topbar {
                display: flex;
            }

            .main-content {
                padding: var(--space-6) var(--space-4) var(--space-12);
            }

            .app {
                flex-direction: column;
            }
        }

        /* ===== Components ===== */

        /* Card */
        .card {
            background: var(--surface);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-sm);
            transition: all var(--transition);
            overflow: hidden;
        }

        .card:hover {
            box-shadow: var(--shadow-md);
            transform: translateY(-2px);
            border-color: var(--color-primary-light);
        }

        .card-body {
            padding: var(--space-6);
        }

        .card-header {
            padding: var(--space-6) var(--space-6) 0;
        }

        .card-footer {
            padding: 0 var(--space-6) var(--space-6);
        }

        /* Button */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-2);
            padding: 0.625rem 1.25rem;
            border-radius: var(--radius);
            font-weight: 600;
            font-size: 0.875rem;
            line-height: 1.25;
            transition: all var(--transition-fast);
            white-space: nowrap;
            user-select: none;
            border: 1px solid transparent;
        }

        .btn:active {
            transform: scale(0.98);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: var(--color-primary);
            color: white;
            box-shadow: 0 4px 12px rgba(var(--color-primary-rgb), 0.2);
        }

        .btn-primary:hover:not(:disabled) {
            background: var(--color-primary-dark);
            box-shadow: 0 6px 16px rgba(var(--color-primary-rgb), 0.3);
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .btn-secondary:hover:not(:disabled) {
            background: var(--bg-secondary);
            border-color: var(--border-color-strong);
        }

        .btn-ghost {
            background: transparent;
            color: var(--text-secondary);
        }

        .btn-ghost:hover:not(:disabled) {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .btn-danger {
            background: var(--color-danger);
            color: white;
        }

        .btn-danger:hover:not(:disabled) {
            background: #b91c1c;
        }

        .btn-sm {
            padding: 0.4rem 0.8rem;
            font-size: 0.75rem;
        }

        .btn-lg {
            padding: 0.8rem 1.6rem;
            font-size: 1rem;
        }

        /* Icon Button */
        .icon-btn {
            width: 2.5rem;
            height: 2.5rem;
            padding: 0;
            border-radius: var(--radius);
            border: 1px solid var(--border-color);
            background: var(--surface);
            color: var(--text-secondary);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: all var(--transition-fast);
        }

        .icon-btn:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border-color: var(--color-primary-light);
            transform: rotate(5deg);
        }

        /* Form Elements */
        .input {
            width: 100%;
            padding: 0.75rem 1rem;
            background: var(--bg-body);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            color: var(--text-primary);
            font-size: 0.875rem;
            transition: all var(--transition-fast);
        }

        .input:hover {
            border-color: var(--border-color-strong);
        }

        .input:focus {
            border-color: var(--color-primary);
            box-shadow: var(--focus-ring);
            background: var(--surface);
        }

        .input::placeholder {
            color: var(--text-muted);
        }

        textarea.input {
            min-height: 120px;
            resize: vertical;
        }

        select.input {
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3E%3Cpath stroke='%2364748b' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3E%3C/svg%3E");
            background-position: right 0.75rem center;
            background-repeat: no-repeat;
            background-size: 1.25rem;
            padding-right: 2.5rem;
        }

        /* Badge */
        .badge {
            display: inline-flex;
            align-items: center;
            gap: var(--space-1);
            padding: 0.25rem 0.75rem;
            font-size: 0.75rem;
            font-weight: 700;
            border-radius: var(--radius-full);
            border: 1px solid transparent;
            white-space: nowrap;
            letter-spacing: 0.02em;
        }

        .badge-primary {
            background: rgba(var(--color-primary-rgb), 0.1);
            color: var(--color-primary);
        }

        .badge-success {
            background: rgba(var(--color-success-rgb), 0.1);
            color: var(--color-success);
        }

        .badge-warning {
            background: rgba(var(--color-warning-rgb), 0.1);
            color: var(--color-warning);
        }

        .badge-secondary {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border-color: var(--border-color);
        }

        /* Navigation */
        .nav-title {
            margin: var(--space-8) var(--space-3) var(--space-3);
            font-size: 0.75rem;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: var(--text-muted);
            font-weight: 800;
        }

        .nav-link {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            padding: 0.75rem 1rem;
            border-radius: var(--radius);
            color: var(--text-secondary);
            font-weight: 500;
            transition: all var(--transition-fast);
            margin-bottom: 0.25rem;
        }

        .nav-link:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            transform: translateX(4px);
        }

        .nav-link.active {
            background: rgba(var(--color-primary-rgb), 0.1);
            color: var(--color-primary);
            font-weight: 700;
        }

        .nav-link svg {
            width: 1.25rem;
            height: 1.25rem;
            transition: transform var(--transition-fast);
        }

        .nav-link:hover svg {
            transform: scale(1.1);
        }

        /* Typography Utilities */
        .h1 { font-size: 2.5rem; font-weight: 800; margin-bottom: var(--space-6); color: var(--text-primary); }
        .h2 { font-size: 1.875rem; font-weight: 700; margin-bottom: var(--space-4); color: var(--text-primary); }
        .h3 { font-size: 1.5rem; font-weight: 700; margin-bottom: var(--space-3); color: var(--text-primary); }
        .text-muted { color: var(--text-tertiary); }
        .text-sm { font-size: 0.875rem; }
        .text-xs { font-size: 0.75rem; }
        .font-mono { font-family: var(--font-mono); }

        /* Helpers */
        .flex { display: flex; }
        .flex-col { flex-direction: column; }
        .items-center { align-items: center; }
        .justify-between { justify-content: space-between; }
        .flex-wrap { flex-wrap: wrap; }
        .gap-1 { gap: var(--space-1); }
        .gap-2 { gap: var(--space-2); }
        .gap-3 { gap: var(--space-3); }
        .gap-4 { gap: var(--space-4); }
        .gap-6 { gap: var(--space-6); }
        .gap-8 { gap: var(--space-8); }
        .mt-1 { margin-top: var(--space-1); }
        .mt-2 { margin-top: var(--space-2); }
        .mt-3 { margin-top: var(--space-3); }
        .mt-4 { margin-top: var(--space-4); }
        .mt-6 { margin-top: var(--space-6); }
        .mb-1 { margin-bottom: var(--space-1); }
        .mb-2 { margin-bottom: var(--space-2); }
        .mb-4 { margin-bottom: var(--space-4); }
        .mb-6 { margin-bottom: var(--space-6); }
        .p-4 { padding: var(--space-4); }
        .p-6 { padding: var(--space-6); }
        .w-full { width: 100%; }
        .max-w-2xl { max-width: 42rem; }
        .max-w-4xl { max-width: 56rem; }
        .cursor-pointer { cursor: pointer; }
        .grid { display: grid; }
        .grid-cols-1 { grid-template-columns: repeat(1, minmax(0, 1fr)); }
        .grid-cols-2 { grid-template-columns: repeat(2, minmax(0, 1fr)); }
        @media (min-width: 640px) { .sm\:grid-cols-2 { grid-template-columns: repeat(2, minmax(0, 1fr)); } }
        @media (min-width: 1024px) { .lg\:grid-cols-3 { grid-template-columns: repeat(3, minmax(0, 1fr)); } }

        /* Animation */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        #content > * {
            animation: fadeIn 0.4s ease-out forwards;
        }
    </style>
    
    <base target="_blank">
    <base target="_blank">
</head>

<body>
    <!-- Skip Link for Accessibility -->
    <a href="#main-content" class="skip-link">メインコンテンツへスキップ</a>

    <!-- ARIA Live Region for Screen Readers -->
    <div id="page-announcement" class="aria-live" aria-live="polite" aria-atomic="true"></div>

    <!-- Mobile Topbar -->
    <header class="topbar" id="topbar">
        <button class="icon-btn" id="menuBtn" aria-label="メニューを開く" aria-expanded="false">
            <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M4 6h16M4 12h16M4 18h16" />
            </svg>
        </button>
        <div class="brand">Portfolio</div>
        <div style="flex:1"></div>
        <button class="icon-btn" id="themeBtnTop" aria-label="テーマ切替">
            <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2">
                <path
                    d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707" />
                <circle cx="12" cy="12" r="4" />
            </svg>
        </button>
    </header>

    <!-- Mobile Overlay -->
    <div class="overlay" id="overlay" role="presentation" aria-hidden="true"></div>

    <!-- Mobile Drawer -->
    <aside class="drawer" id="drawer" role="dialog" aria-modal="true" aria-label="ナビゲーションメニュー"></aside>

    <!-- Main App -->
    <div class="app" id="app">
        <!-- Desktop Sidebar -->
        <nav class="sidebar" id="sidebar" aria-label="メインナビゲーション"></nav>

        <!-- Main Content Area -->
        <main id="main-content" class="main-content" tabindex="-1">
            <div class="container" id="content"></div>
        </main>
    </div>

    <script>

        /**
         * Portfolio SPA - Enhanced Version
         * Single HTML architecture with modern ES6+ patterns
         */

        'use strict';

        // ===== Module Pattern: Constants =====
        const CONSTANTS = {
            STORAGE_KEY: 'portfolio_enhanced_v10',
            SNAPSHOT_KEY: 'portfolio_snapshot_v10',
            SCHEMA_VERSION: 10,

            // Cross-tab coordination
            TAB_ID: (() => {
                try {
                    const key = 'portfolio_tab_id_v10';
                    let id = sessionStorage.getItem(key);
                    if (!id) {
                        id = crypto.randomUUID ? crypto.randomUUID() :
                            'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
                                const r = Math.random() * 16 | 0;
                                return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
                            });
                        sessionStorage.setItem(key, id);
                    }
                    return id;
                } catch {
                    return Math.random().toString(36).substring(2);
                }
            })(),

            // Limits for validation
            LIMITS: {
                PROJECT_NAME: 120,
                PROJECT_ID: 80,
                CATEGORY: 80,
                SUMMARY: 800,
                PROBLEM: 1200,
                APPROACH: 1200,
                IMPACT: 1200,
                TASK_TITLE: 200,
                TASK_DESC: 1000,
                TODO_TEXT: 300,
                AI_MESSAGE: 5000,
                MAX_PROJECTS: 1000,
                MAX_TASKS: 500,
                MAX_TODOS: 1000,
            },

            // Timing
            DEBOUNCE_DELAY: 150,
            SAVE_INTERVAL: 30000,
            POMODORO_LOCK_TTL: 8000,
        };

        // ===== Icons (SVG) =====
        const ICONS = {
            menu: `<path d="M4 6h16M4 12h16M4 18h16"/>`,
            sun: `<path d="M12 18a6 6 0 1 0 0-12 6 6 0 0 0 0 12Z"/><path d="M12 2v2M12 20v2M4.93 4.93l1.41 1.41M17.66 17.66l1.41 1.41M2 12h2M20 12h2M4.93 19.07l1.41-1.41M17.66 6.34l1.41-1.41"/>`,
            moon: `<path d="M21 12.79A9 9 0 1 1 11.21 3a7 7 0 0 0 9.79 9.79Z"/>`,
            home: `<path d="M3 10.5 12 3l9 7.5V21a1 1 0 0 1-1 1h-5v-6h-6v6H4a1 1 0 0 1-1-1v-10.5Z"/>`,
            briefcase: `<path d="M10 3h4a2 2 0 0 1 2 2v2h-8V5a2 2 0 0 1 2-2Z"/><path d="M4 7h16a2 2 0 0 1 2 2v3a3 3 0 0 1-3 3h-1v-2h-12v2H5a3 3 0 0 1-3-3V9a2 2 0 0 1 2-2Z"/><path d="M4 15v5a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-5"/>`,
            apps: `<path d="M4 4h7v7H4V4Zm9 0h7v7h-7V4ZM4 13h7v7H4v-7Zm9 0h7v7h-7v-7Z"/>`,
            checkSquare: `<path d="M9 11l2 2 4-4"/><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/>`,
            list: `<path d="M8 6h13M8 12h13M8 18h13"/><path d="M3 6h.01M3 12h.01M3 18h.01"/>`,
            clock: `<path d="M12 8v5l3 3"/><path d="M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"/>`,
            brain: `<path d="M8.5 4.5a3 3 0 0 0-3 3v1a3 3 0 0 0 0 6v1a3 3 0 0 0 3 3"/><path d="M15.5 4.5a3 3 0 0 1 3 3v1a3 3 0 0 1 0 6v1a3 3 0 0 1-3 3"/><path d="M9 7h.01M9 11h.01M9 15h.01M15 7h.01M15 11h.01M15 15h.01"/>`,
            settings: `<path d="M12 15.5a3.5 3.5 0 1 0 0-7 3.5 3.5 0 0 0 0 7Z"/><path d="M19.4 15a7.8 7.8 0 0 0 .1-2l2-1.2-2-3.5-2.3.6a7.3 7.3 0 0 0-1.7-1L15 3h-6l-.7 2.9a7.3 7.3 0 0 0-1.7 1L4.3 6.3l-2 3.5 2 1.2a7.8 7.8 0 0 0 0 2l-2 1.2 2 3.5 2.3-.6a7.3 7.3 0 0 0 1.7 1L9 21h6l.7-2.9a7.3 7.3 0 0 0 1.7-1l2.3.6 2-3.5-2-1.2Z"/>`,
            search: `<path d="M21 21l-4.3-4.3"/><path d="M10 18a8 8 0 1 1 0-16 8 8 0 0 1 0 16Z"/>`,
            upload: `<path d="M12 3v12"/><path d="m7 8 5-5 5 5"/><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>`,
            download: `<path d="M12 3v12"/><path d="m7 10 5 5 5-5"/><path d="M21 21H3"/>`,
            trash: `<path d="M3 6h18"/><path d="M8 6V4h8v2"/><path d="M10 11v6M14 11v6"/><path d="M6 6l1 16h10l1-16"/>`,
            x: `<path d="M18 6 6 18M6 6l12 12"/>`,
            arrowUpRight: `<path d="M7 17 17 7"/><path d="M10 7h7v7"/>`,
            play: `<path d="M8 5v14l11-7-11-7Z"/>`,
            pause: `<path d="M6 5h4v14H6zM14 5h4v14h-4z"/>`,
            rotate: `<path d="M21 12a9 9 0 1 1-3-6.7"/><path d="M21 3v7h-7"/>`,
            alert: `<path d="M12 9v4"/><path d="M12 17h.01"/><path d="M10.3 3.7a2 2 0 0 1 3.4 0l8 13.9a2 2 0 0 1-1.7 3H4a2 2 0 0 1-1.7-3l8-13.9Z"/>`,
            check: `<path d="M20 6 9 17l-5-5"/>`,
            up: `<path d="M12 19V5"/><path d="m5 12 7-7 7 7"/>`,
            down: `<path d="M12 5v14"/><path d="m19 12-7 7-7-7"/>`,
            pin: `<path d="M14 9V4h-4v5L7 12v3h10v-3l-3-3Z"/><path d="M12 15v7"/>`,
            plus: `<path d="M12 5v14M5 12h14"/>`,
            user: `<path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/>`,
            mail: `<path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/>`,
            github: `<path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"/>`,
            linkedin: `<path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/>`,
            filter: `<polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"/>`,
            tag: `<path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/>`,
            calendar: `<rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/>`,
            edit: `<path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>`,
        };

        // ===== Helper: Create SVG Icon =====
        function createIcon(name, size = 20) {
            const paths = ICONS[name];
            if (!paths) return document.createTextNode('');

            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('viewBox', '0 0 24 24');
            svg.setAttribute('width', size);
            svg.setAttribute('height', size);
            svg.setAttribute('fill', 'none');
            svg.setAttribute('stroke', 'currentColor');
            svg.setAttribute('stroke-width', '2');
            svg.setAttribute('stroke-linecap', 'round');
            svg.setAttribute('stroke-linejoin', 'round');
            svg.setAttribute('aria-hidden', 'true');
            svg.innerHTML = paths;
            return svg;
        }

        // ===== Helper: DOM Builder (Type-safe XSS prevention) =====
        function h(tag, attrs = {}, ...children) {
            const el = document.createElement(tag);
            let refCb = null;

            for (const [key, value] of Object.entries(attrs)) {
                if (value === undefined || value === null) continue;

                if (key === 'ref' && typeof value === 'function') {
                    refCb = value;
                    continue;
                }

                if (key === 'class') {
                    if (Array.isArray(value)) {
                        el.className = value.filter(Boolean).join(' ');
                    } else {
                        el.className = String(value);
                    }
                } else if (key === 'style') {
                    if (typeof value === 'object') {
                        Object.assign(el.style, value);
                    } else {
                        el.style.cssText = String(value);
                    }
                } else if (key === 'dataset' && typeof value === 'object') {
                    Object.entries(value).forEach(([k, v]) => {
                        if (v !== undefined) el.dataset[k] = String(v);
                    });
                } else if (key.startsWith('on') && typeof value === 'function') {
                    el.addEventListener(key.slice(2).toLowerCase(), value);
                } else if (key === 'text') {
                    el.textContent = String(value);
                } else if (key === 'html') {
                    // Only for trusted static content
                    el.innerHTML = String(value);
                } else if (key.startsWith('aria')) {
                    el.setAttribute(`aria-${key.slice(4).toLowerCase()}`, String(value));
                } else {
                    el.setAttribute(key, String(value));
                }
            }

            children.flat().forEach(child => {
                if (child === undefined || child === null) return;
                if (child instanceof Node) {
                    el.appendChild(child);
                } else {
                    el.appendChild(document.createTextNode(String(child)));
                }
            });

            if (refCb) {
                try { refCb(el); } catch (e) { console.error(e); }
            }

            return el;
        }

        function clear(node) {
            while (node.firstChild) {
                node.removeChild(node.firstChild);
            }
        }

        // ===== Helper: Safe Storage =====
        const Storage = {
            get(key) {
                try {
                    return localStorage.getItem(key);
                } catch {
                    return null;
                }
            },

            set(key, value) {
                try {
                    localStorage.setItem(key, value);
                    return true;
                } catch {
                    return false;
                }
            },

            remove(key) {
                try {
                    localStorage.removeItem(key);
                    return true;
                } catch {
                    return false;
                }
            },

            parse(key) {
                const data = this.get(key);
                if (!data) return null;
                try {
                    return JSON.parse(data);
                } catch {
                    return null;
                }
            }
        };

        // ===== Helper: Utilities =====
        function uid() {
            if (crypto.randomUUID) return crypto.randomUUID();
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
                const r = Math.random() * 16 | 0;
                return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
            });
        }

        function clamp(num, min, max) {
            return Math.max(min, Math.min(max, num));
        }

        function debounce(fn, delay) {
            let timer;
            return (...args) => {
                clearTimeout(timer);
                timer = setTimeout(() => fn(...args), delay);
            };
        }

        function throttle(fn, limit) {
            let inThrottle;
            return (...args) => {
                if (!inThrottle) {
                    fn(...args);
                    inThrottle = true;
                    setTimeout(() => inThrottle = false, limit);
                }
            };
        }

        function tokenize(s) {
            return String(s || '').toLowerCase().split(/[\s\-_\/\.,:;()\[\]{}"']+/).filter(Boolean);
        }

        function slugify(str) {
            const s = String(str || '').trim().toLowerCase();
            return s.replace(/[\s_]+/g, '-').replace(/[^\w\-\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/g, '') || `p-${uid().slice(0, 8)}`;
        }

        function sanitizeUrl(url) {
            try {
                const u = new URL(url);
                if (u.protocol === 'http:' || u.protocol === 'https:') return u.toString();
                return null;
            } catch {
                return null;
            }
        }

        function deepClone(obj) {
            if (obj === null || typeof obj !== 'object') return obj;
            if (obj instanceof Date) return new Date(obj.getTime());
            if (Array.isArray(obj)) return obj.map(deepClone);
            const cloned = {};
            for (const key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    cloned[key] = deepClone(obj[key]);
                }
            }
            return cloned;
        }

        // ===== Store Module =====
        const Store = (() => {
            // Default Data
            const defaultProfile = {
                name: 'ユウタ',
                title: '謙虚なITエンジニア',
                bio: `ポートフォリオです。このサイトは「完成品を並べる場所」ではなく「作りながら検証するための実験環境」です。

【設計思想】
• 単一HTMLでの完結（依存性最小化）
• セマンティックHTML5 + ARIA対応
• 型安全なDOM操作
• イベント駆動アーキテクチャ`,
                email: 'yuta.pr.0117@gmail.com',
                github: '',
                linkedin: '',
                location: 'Japan',
            };

            const defaultAppsData = {
                tasks: [
                    { id: 't1', title: 'ログの確認', status: 'backlog', priority: 'high', tags: ['運用'], createdAt: Date.now(), updatedAt: Date.now() },
                    { id: 't2', title: '資料の更新', status: 'in-progress', priority: 'low', tags: ['ドキュメント'], createdAt: Date.now(), updatedAt: Date.now() }
                ],
                todos: [
                    { id: 'td1', text: 'コーヒーを買う', completed: false, createdAt: Date.now(), dueDate: null }
                ],
                pomodoro: {
                    history: [],
                    settings: { work: 25, short: 5, long: 15 },
                    runtime: {
                        isActive: false,
                        mode: 'work',
                        endAtMs: null,
                        remainingSec: 1500,
                        linkedTaskId: null
                    }
                },
                ai: { history: [] }
            };

            function proj(id, slug, name, category, summary, problem, approach, outcome, tech, tags, highlights, architecture, relatedIds, links, demoRoute) {
                return {
                    id, slug, name, category,
                    summary, problem, approach,
                    outcome: outcome || { metrics: [], impact: "" },
                    tech: Array.isArray(tech) ? tech : [],
                    tags: Array.isArray(tags) ? tags : [],
                    highlights: Array.isArray(highlights) ? highlights : [],
                    architecture: architecture || { overview: "", mermaid: null },
                    relatedProjectIds: Array.isArray(relatedIds) ? relatedIds : [],
                    links: Array.isArray(links) ? links : [],
                    demoRoute: demoRoute || null
                };
            }

            const defaultProjects = [
                proj("p01", "task-manager", "タスク管理アプリ", "Productivity",
                    "このポートフォリオに統合された、オフライン対応のタスク管理ツール。",
                    "外部依存のあるツールは、障害時に利用できなくなるリスクがある。",
                    "状態・優先度・検索の最低限に絞って堅牢に実装。LocalStorageで永続化。",
                    { metrics: [{ label: "耐障害", value: "local-only" }, { label: "状態", value: "3" }], impact: "運用前提の最小機能で事故率を下げる。" },
                    ["Vanilla JS", "LocalStorage", "Hash Router"],
                    ["ツール", "SPA", "オフライン"], ["検索/フィルタ", "優先度", "状態遷移"],
                    { overview: "単一ストア（appsData.tasks）をUIが参照する構造。" },
                    ["p02", "p03", "p04"], [], "task"
                ),
                proj("p02", "todo-list", "TODOリスト", "Productivity",
                    "クイックTODO。",
                    "高機能システムへ移るたびに思考が途切れる。",
                    "Enter追加 + IMEガード + フィルタ/一括操作に限定。",
                    { metrics: [{ label: "入力導線", value: "Enter" }], impact: "認知負荷を落として記録を継続。" },
                    ["Vanilla JS", "IME guard"], ["ツール", "効率化"], ["一括操作", "検索/フィルタ"],
                    { overview: "appsData.todosを参照。" },
                    ["p01", "p03"], [], "todo"
                ),
                proj("p03", "pomodoro-timer", "ポモドーロタイマー", "Productivity",
                    "タブ休眠・スリープ対応ポモドーロ。",
                    "setIntervalだけだと非アクティブで精度が落ちる。",
                    "endAt(タイムスタンプ)で残秒を復元。二重起動を防止。フォーカス対象（タスク）を記録。",
                    { metrics: [{ label: "復元方式", value: "timestamp" }], impact: "タイマーが信頼できる状態を維持。" },
                    ["Vanilla JS", "Date API"], ["ツール", "時間管理"], ["timestamp復元", "履歴管理", "フォーカス対象"],
                    { overview: "runtime(endAt/remainingSec)を永続化し、tickはUI更新のみ。" },
                    ["p01", "p02", "p04"], [], "pomodoro"
                ),
                proj("p09", "local-ai-assist", "ローカルAIアシスト", "AI",
                    "外部API無しのAIアシスト。",
                    "AI活用は外部依存にすると壊れやすい。",
                    "ルール分類（design/troubleshoot/general）＋テンプレ生成＋根拠表示。",
                    { metrics: [{ label: "依存", value: "none" }], impact: "オフラインで提案が成立。" },
                    ["Rule-based", "Templates"], ["AI", "オフライン"], ["タスク分解", "文章生成"],
                    { overview: "appsData.ai.historyにログ。" },
                    ["p16", "p17", "p18"], [], "ai"
                ),
                proj("p04", "unified-data-model", "データモデル設計", "Productivity",
                    "ローカルアプリ間の整合性を保つ共通スキーマ。",
                    "アプリごとに形式がバラバラだと、移行や復旧が破綻する。",
                    "schemaVersion付きストア + フォールバック + Import/Export設計。整合性チェック/自動修復導線。",
                    { metrics: [{ label: "schema", value: "v2" }, { label: "復旧", value: "safe" }], impact: "破損時も初期化・復元が可能。" },
                    ["Schema", "Migration"], ["アーキテクチャ", "データ"], ["破損フォールバック", "Import/Export", "自動修復"],
                    { overview: "full-store(schemaVersion:2)を採用。" },
                    ["p01", "p02", "p03", "p18"], [], null
                ),
                proj("p05", "offline-sync-notes", "オフライン同期設計メモ", "Productivity",
                    "将来同期を見据えた競合解決の整理。",
                    "同期時の衝突は後から直せない温床になりやすい。",
                    "Upsert/Strictの方針や、衝突キーの設計を文書化。",
                    { metrics: [{ label: "方針", value: "append/upsert/strict" }], impact: "運用ポリシーを先に固定。" },
                    ["Design Notes"], ["設計", "運用"], ["衝突キー", "適用モード"],
                    { overview: "settingsでインポート結果を可視化。" },
                    ["p04"], [], null
                ),
                proj("p06", "telemetry-starter", "テレメトリ基盤コンセプト", "Observability",
                    "フロントのイベント/ログ/計測の統一案。",
                    "ログ形式がバラバラだと調査コストが上がる。",
                    "イベントラッパー + 最低限の構造化ログ方針を定義。",
                    { metrics: [{ label: "形式", value: "structured" }], impact: "再現可能な調査手順の土台。" },
                    ["Structured Logging"], ["DevOps", "運用"], ["統一フォーマット", "最小実装"],
                    { overview: "実装は本SPAのsafe方針に反映。" },
                    ["p07", "p08"], [], null
                ),
                proj("p07", "slo-dashboard", "SLOダッシュボード試作（UI）", "Observability",
                    "SLO/SLIを読み解くUIの構造案。",
                    "数字があるのに意思決定に繋がらないことがある。",
                    "“見る順序”をUIに埋め込む。フィルタとハイライトを先に置く。",
                    { metrics: [{ label: "導線", value: "filter-first" }], impact: "意思決定の遅延を減らす。" },
                    ["UI Design"], ["UI", "運用"], ["フィルタ優先", "視認性"],
                    { overview: "Projects一覧の検索/カテゴリ選択に思想を反映。" },
                    ["p06"], [], null
                ),
                proj("p08", "incident-playbook", "インシデント手順プレイブック", "Observability",
                    "事故時に手順抜けを防ぐチェックリスト。",
                    "緊急時は認知負荷が上がり、抜けが生まれる。",
                    "手順をUI化し、確認ボックスの順序を固定。",
                    { metrics: [{ label: "抜け防止", value: "checklist" }], impact: "初動品質を底上げ。" },
                    ["Checklist"], ["プロセス", "運用"], ["手順固定", "可視化"],
                    { overview: "Task/Todoの最小操作性にも同じ思想。" },
                    ["p06", "p09"], [], null
                ),
                proj("p10", "ci-quality-gate", "CIクオリティゲート設計", "Platform",
                    "Lint/Test/Typecheckのゲート設計。",
                    "品質の劣化は後工程でコスト爆増する。",
                    "最小ゲートを固定し、失敗時に原因が即分かる形へ。",
                    { metrics: [{ label: "ゲート", value: "3" }], impact: "品質劣化の混入を抑制。" },
                    ["Quality Gates"], ["CI/CD"], ["最小セット", "原因特定"],
                    { overview: "本HTMLは例外ガード/検証を先に固定。" },
                    ["p11"], [], null
                ),
                proj("p11", "release-notes-builder", "リリースノート生成（ルール）", "Platform",
                    "変更ログのテンプレ生成。",
                    "記録が残らないと説明責任が崩れる。",
                    "テンプレ生成 + 必須項目の抜け検出を設計。",
                    { metrics: [{ label: "テンプレ", value: "fixed" }], impact: "説明の再現性が上がる。" },
                    ["Templates"], ["自動化"], ["抜け検出", "規格化"],
                    { overview: "AIアシストのテンプレ生成に思想を反映。" },
                    ["p10", "p17"], [], null
                ),
                proj("p12", "design-system-mini", "ミニデザインシステム", "Platform",
                    "最低限のUI部品を揃え、崩れを防ぐ。",
                    "画面ごとに見た目が違うと学習コストが増える。",
                    "ボタン/カード/バッジ/入力などを統一。",
                    { metrics: [{ label: "部品", value: "atoms" }], impact: "見た目の一貫性でUXを安定化。" },
                    ["CSS Variables"], ["UI/UX"], ["一貫性", "focus-visible"],
                    { overview: "単一CSSでテーマ/余白/階層を統一。" },
                    ["p01", "p02", "p03"], [], null
                ),
                proj("p13", "security-baseline", "セキュリティベースライン", "Security",
                    "Webアプリの最低限チェック。",
                    "基本が抜けると致命傷になる。",
                    "XSS/リンク安全/入力検証/外部依存の境界を固定。",
                    { metrics: [{ label: "XSS", value: "textContent" }], impact: "壊れ方を減らす。" },
                    ["Safe DOM"], ["セキュリティ"], ["XSS回避", "境界固定"],
                    { overview: "ユーザー入力はDOMにtextとしてのみ挿入。" },
                    ["p14", "p15"], [], null
                ),
                proj("p14", "secrets-handling", "設定値管理ガイド", "Security",
                    "秘匿情報をフロントへ入れない設計。",
                    "クライアント側に秘密は置けない。",
                    "外部API不要のAIアシストで運用を成立させる方針。",
                    { metrics: [{ label: "外部API", value: "optional" }], impact: "安全側で成立させる。" },
                    ["Boundary Design"], ["運用", "セキュリティ"], ["責任境界", "非依存"],
                    { overview: "単一HTMLはネットワーク不要で動作。" },
                    ["p13"], [], null
                ),
                proj("p15", "link-sanitization", "リンク検証ユーティリティ", "Security",
                    "http/httpsのみ許可するURL検証。",
                    "リンク注入は温床になりやすい。",
                    "URL API + allowlist。",
                    { metrics: [{ label: "protocol", value: "http/https" }], impact: "不正URLを排除。" },
                    ["URL API"], ["セキュリティ"], ["sanitize", "noopener"],
                    { overview: "外部リンクはrel=noopener/noreferrerを付与。" },
                    ["p13"], [], null
                ),
                proj("p16", "task-breakdown-engine", "タスク分解エンジン", "AI",
                    "キーワードに基づく標準手順の提案。",
                    "作業開始できない状態は生産性を壊す。",
                    "分類→テンプレ→チェックリスト化。",
                    { metrics: [{ label: "分類", value: "3-mode" }], impact: "開始までの摩擦を下げる。" },
                    ["Rule-based"], ["AI", "生産性"], ["分解", "根拠表示"],
                    { overview: "ローカルルールエンジンを内蔵。" },
                    ["p01", "p09", "p18"], [], "ai"
                ),
                proj("p17", "portfolio-copy-generator", "ポートフォリオ文章生成", "AI",
                    "ケーススタディ文章の生成支援。",
                    "文章作成に時間がかかる。",
                    "トーン別テンプレ + ルール根拠の表示。",
                    { metrics: [{ label: "トーン", value: "2" }], impact: "説明文作成の工数を削減。" },
                    ["Templates"], ["AI"], ["professional/casual", "根拠表示"],
                    { overview: "AIアシストで実装。" },
                    ["p09", "p11"], [], "ai"
                ),
                proj("p18", "local-semantic-search", "ローカル検索スコアリング", "AI",
                    "Projects検索の精度改善（依存なし）。",
                    "完全一致だけだと探しにくい。",
                    "トークン化→簡易スコア→降順表示。",
                    { metrics: [{ label: "deps", value: "0" }], impact: "検索性の底上げ。" },
                    ["Scoring"], ["検索", "AI"], ["token scoring", "lightweight"],
                    { overview: "Projects一覧の検索にスコアリングを導入。" },
                    ["p04", "p09"], [], null
                ),
            ];

            // Load store with migration
            function load() {
                const data = Storage.parse(CONSTANTS.STORAGE_KEY);
                if (!data || data.schemaVersion !== CONSTANTS.SCHEMA_VERSION) {
                    return createDefaultStore();
                }
                return validateAndNormalize(data);
            }

            function createDefaultStore() {
                return {
                    schemaVersion: CONSTANTS.SCHEMA_VERSION,
                    type: 'full-store',
                    profile: deepClone(defaultProfile),
                    projects: deepClone(defaultProjects),
                    appsData: deepClone(defaultAppsData),
                    projectPrefs: { hiddenIds: [] },
                    theme: 'system',
                    lastModified: Date.now(),
                };
            }

            function validateAndNormalize(data) {
                const store = createDefaultStore();

                // Merge profile
                if (data.profile && typeof data.profile === 'object') {
                    store.profile = {
                        ...store.profile,
                        name: String(data.profile.name || store.profile.name).slice(0, CONSTANTS.LIMITS.PROJECT_NAME),
                        title: String(data.profile.title || store.profile.title).slice(0, CONSTANTS.LIMITS.CATEGORY),
                        bio: String(data.profile.bio || store.profile.bio).slice(0, 5000),
                        email: String(data.profile.email || store.profile.email),
                    };
                }

                // Merge projects (lossless): keep all defaults (v2 baseline) + preserve user edits + keep user-added projects
                if (Array.isArray(data.projects)) {
                    store.projects = mergeProjectsWithDefaults(data.projects);
                }

                // Merge apps data
                if (data.appsData && typeof data.appsData === 'object') {
                    store.appsData = normalizeAppsData(data.appsData);
                }

                // Theme
                if (['light', 'dark', 'system'].includes(data.theme)) {
                    store.theme = data.theme;
                }


                // Project preferences (hidden list)
                if (data.projectPrefs && typeof data.projectPrefs === 'object' && Array.isArray(data.projectPrefs.hiddenIds)) {
                    store.projectPrefs = { hiddenIds: data.projectPrefs.hiddenIds.map(String).filter(Boolean).slice(0, 1000) };
                }

                return store;
            }

            function normalizeProject(raw, idx) {
                const id = String(raw.id || `p${idx}_${uid()}`).slice(0, CONSTANTS.LIMITS.PROJECT_ID);
                const slug = String(raw.slug || slugify(raw.name || id)).slice(0, 100);

                return {
                    id,
                    slug,
                    name: String(raw.name || 'Untitled').slice(0, CONSTANTS.LIMITS.PROJECT_NAME),
                    category: String(raw.category || 'Misc').slice(0, CONSTANTS.LIMITS.CATEGORY),
                    summary: String(raw.summary || '').slice(0, CONSTANTS.LIMITS.SUMMARY),
                    problem: String(raw.problem || '').slice(0, CONSTANTS.LIMITS.PROBLEM),
                    approach: String(raw.approach || '').slice(0, CONSTANTS.LIMITS.APPROACH),
                    outcome: {
                        impact: String(raw.outcome?.impact || '').slice(0, CONSTANTS.LIMITS.IMPACT),
                        metrics: Array.isArray(raw.outcome?.metrics)
                            ? raw.outcome.metrics.slice(0, 12).filter(m => m && m.label && m.value)
                            : []
                    },
                    tech: (raw.tech || []).filter(Boolean).slice(0, 12),
                    tags: (raw.tags || []).filter(Boolean).slice(0, 12),
                    highlights: (raw.highlights || []).filter(Boolean).slice(0, 20),
                    architecture: {
                        overview: String(raw.architecture?.overview || '').slice(0, 2000),
                        mermaid: raw.architecture?.mermaid || null
                    },
                    relatedProjectIds: (raw.relatedProjectIds || []).filter(Boolean).slice(0, 20),
                    links: (raw.links || []).filter(l => l && l.label && sanitizeUrl(l.url)).slice(0, 30),
                    demoRoute: ['task', 'todo', 'pomodoro', 'ai'].includes(raw.demoRoute) ? raw.demoRoute : null
                };
            }

            // ===== v10: Similarity-based recommendations (v2 feature, adapted) =====
            function tokenizeForSimilarity(s) {
                const str = String(s || '');
                const parts = (str.match(/[A-Za-z0-9]+|[\u3040-\u30ff\u4e00-\u9fff]+/g) || [])
                    .map(x => x.toLowerCase().trim())
                    .filter(x => x.length >= 2);
                return Array.from(new Set(parts)).slice(0, 200);
            }

            function jaccard(a, b) {
                const A = new Set(Array.isArray(a) ? a.map(String) : []);
                const B = new Set(Array.isArray(b) ? b.map(String) : []);
                if (!A.size && !B.size) return 0;
                let inter = 0;
                for (const x of A) if (B.has(x)) inter++;
                const uni = A.size + B.size - inter;
                return uni ? inter / uni : 0;
            }

            function similarityScoreV10(a, b) {
                if (!a || !b) return 0;
                const tagScore = jaccard(a.tags, b.tags);
                const techScore = jaccard(a.tech, b.tech);
                const catScore = (a.category && b.category && String(a.category) === String(b.category)) ? 1 : 0;

                const textA = [a.name, a.summary, a.problem, a.approach].join(' ');
                const textB = [b.name, b.summary, b.problem, b.approach].join(' ');
                const ta = new Set(tokenizeForSimilarity(textA));
                const tb = new Set(tokenizeForSimilarity(textB));
                let inter = 0;
                for (const t of ta) if (tb.has(t)) inter++;
                const textScore = (ta.size + tb.size) ? (2 * inter / (ta.size + tb.size)) : 0;

                const score = (0.40 * tagScore) + (0.30 * techScore) + (0.15 * catScore) + (0.15 * textScore);
                return Math.max(0, Math.min(1, score));
            }

            function autoRelatedCandidatesV10(target, projects, limit = 8) {
                const fixed = new Set((target && target.relatedProjectIds) ? target.relatedProjectIds : []);
                return (Array.isArray(projects) ? projects : [])
                    .filter(p => p && p.id && target && p.id !== target.id && !fixed.has(p.id))
                    .map(p => ({ p, s: similarityScoreV10(target, p) }))
                    .filter(x => x.s > 0)
                    .sort((a, b) => b.s - a.s)
                    .slice(0, limit)
                    .map(x => x.p);
            }



            // ===== Migration helper: keep all default projects (v2 baseline) while preserving user edits =====
            function mergeProjectsWithDefaults(incomingProjects) {
                const normalizedIncoming = (Array.isArray(incomingProjects) ? incomingProjects : [])
                    .filter(p => p && typeof p === 'object')
                    .map((p, idx) => normalizeProject(p, idx))
                    .slice(0, CONSTANTS.LIMITS.MAX_PROJECTS);

                const normalizedDefaults = deepClone(defaultProjects)
                    .filter(p => p && typeof p === 'object')
                    .map((p, idx) => normalizeProject(p, idx));

                const incomingById = new Map(normalizedIncoming.map(p => [p.id, p]));

                const merged = normalizedDefaults.map(d => {
                    const inc = incomingById.get(d.id);
                    return inc ? ({ ...d, ...inc, id: d.id }) : d;
                });

                const mergedIds = new Set(merged.map(p => p.id));
                for (const p of normalizedIncoming) {
                    if (!mergedIds.has(p.id)) {
                        merged.push(p);
                        mergedIds.add(p.id);
                    }
                }

                return merged.slice(0, CONSTANTS.LIMITS.MAX_PROJECTS);
            }


            function normalizeAppsData(data) {
                const result = deepClone(defaultAppsData);

                // Tasks
                if (Array.isArray(data.tasks)) {
                    result.tasks = data.tasks
                        .filter(t => t && t.title)
                        .map(t => ({
                            id: String(t.id || uid()),
                            title: String(t.title).slice(0, CONSTANTS.LIMITS.TASK_TITLE),
                            status: ['backlog', 'in-progress', 'done'].includes(t.status) ? t.status : 'backlog',
                            priority: ['low', 'med', 'high'].includes(t.priority) ? t.priority : 'med',
                            tags: (t.tags || []).filter(Boolean).slice(0, 10),
                            createdAt: Number(t.createdAt) || Date.now(),
                            updatedAt: Number(t.updatedAt) || Date.now()
                        }))
                        .slice(0, CONSTANTS.LIMITS.MAX_TASKS);
                }

                // Todos
                if (Array.isArray(data.todos)) {
                    result.todos = data.todos
                        .filter(t => t && t.text)
                        .map(t => ({
                            id: String(t.id || uid()),
                            text: String(t.text).slice(0, CONSTANTS.LIMITS.TODO_TEXT),
                            completed: Boolean(t.completed),
                            createdAt: Number(t.createdAt) || Date.now(),
                            dueDate: t.dueDate ? Number(t.dueDate) : null
                        }))
                        .slice(0, CONSTANTS.LIMITS.MAX_TODOS);
                }

                // Pomodoro
                if (data.pomodoro) {
                    if (data.pomodoro.settings) {
                        result.pomodoro.settings = {
                            work: clamp(Number(data.pomodoro.settings.work) || 25, 1, 180),
                            short: clamp(Number(data.pomodoro.settings.short) || 5, 1, 60),
                            long: clamp(Number(data.pomodoro.settings.long) || 15, 1, 120)
                        };
                    }
                    if (data.pomodoro.history) {
                        result.pomodoro.history = data.pomodoro.history.slice(-200);
                    }
                    if (data.pomodoro.runtime) {
                        const rt = data.pomodoro.runtime;
                        const mode = ['work', 'short-break', 'long-break'].includes(rt.mode) ? rt.mode : 'work';
                        const isActive = Boolean(rt.isActive) && rt.endAtMs && rt.endAtMs > Date.now();
                        result.pomodoro.runtime = {
                            isActive,
                            mode,
                            endAtMs: isActive ? rt.endAtMs : null,
                            remainingSec: clamp(Number(rt.remainingSec) || 1500, 0, 86400),
                            linkedTaskId: rt.linkedTaskId || null
                        };
                    }
                }

                // AI History
                if (data.ai?.history) {
                    result.ai.history = data.ai.history
                        .filter(h => h && h.prompt && h.response)
                        .slice(-80);
                }

                return result;
            }

            return { load, createDefaultStore, validateAndNormalize };
        })();

        // ===== State Management =====
        const State = (() => {
            let data = Store.load();
            let saveTimer = null;
            let callbacks = [];

            function get() {
                return data;
            }

            function set(newData) {
                data = { ...newData, lastModified: Date.now() };
                notify();
                scheduleSave();
            }

            function update(fn) {
                const newData = deepClone(data);
                fn(newData);
                set(newData);
            }

            function subscribe(callback) {
                callbacks.push(callback);
                return () => {
                    callbacks = callbacks.filter(cb => cb !== callback);
                };
            }

            function notify() {
                callbacks.forEach(cb => {
                    try { cb(data); } catch (e) { console.error(e); }
                });
            }

            function scheduleSave() {
                if (saveTimer) clearTimeout(saveTimer);
                saveTimer = setTimeout(() => {
                    Storage.set(CONSTANTS.STORAGE_KEY, JSON.stringify(data));
                    saveTimer = null;
                }, CONSTANTS.DEBOUNCE_DELAY);
            }

            function saveNow() {
                if (saveTimer) clearTimeout(saveTimer);
                Storage.set(CONSTANTS.STORAGE_KEY, JSON.stringify(data));
            }

            // Auto-save on visibility change
            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'hidden') saveNow();
            });

            window.addEventListener('beforeunload', saveNow);

            // Cross-tab sync
            window.addEventListener('storage', (e) => {
                if (e.key === CONSTANTS.STORAGE_KEY && e.newValue) {
                    try {
                        const newData = JSON.parse(e.newValue);
                        if (newData.lastModified > data.lastModified) {
                            data = newData;
                            notify();
                            Toast.show('別タブで更新されました', 'info');
                        }
                    } catch { }
                }
            });

            return { get, set, update, subscribe, saveNow };
        })();

        // ===== Toast Notification System =====
        const Toast = (() => {
            let container = null;
            let toasts = [];

            function init() {
                if (!container) {
                    container = document.createElement('div');
                    container.id = 'toast-container';
                    container.setAttribute('role', 'status');
                    container.setAttribute('aria-live', 'polite');
                    container.style.cssText = `
                        position: fixed;
                        top: 1.5rem;
                        right: 1.5rem;
                        z-index: 9999;
                        display: flex;
                        flex-direction: column;
                        gap: 0.5rem;
                    `;
                    document.body.appendChild(container);
                }
            }

            function show(message, type = 'success', duration = 3000) {
                init();

                const el = document.createElement('div');
                el.className = `alert alert-${type}`;
                el.style.cssText = `
                    animation: slideIn 0.3s ease;
                    max-width: 400px;
                    box-shadow: var(--shadow-xl);
                `;
                el.textContent = message;

                const closeBtn = h('button', {
                    class: 'icon-btn',
                    style: { marginLeft: 'auto' },
                    onclick: () => remove(el)
                }, createIcon('x', 16));

                el.appendChild(closeBtn);
                container.appendChild(el);
                toasts.push(el);

                // ARIA announcement
                const live = document.getElementById('page-announcement');
                if (live) live.textContent = message;

                if (duration > 0) {
                    setTimeout(() => remove(el), duration);
                }

                return el;
            }

            function remove(el) {
                el.style.animation = 'slideIn 0.3s ease reverse';
                setTimeout(() => {
                    el.remove();
                    toasts = toasts.filter(t => t !== el);
                }, 300);
            }

            return { show };
        })();

        // ===== Theme Manager =====
        const Theme = (() => {
            function apply(theme) {
                document.documentElement.setAttribute('data-theme', theme);

                const isDark = theme === 'dark' ||
                    (theme === 'system' && window.matchMedia('(prefers-color-scheme: dark)').matches);

                document.documentElement.classList.toggle('dark', isDark);

                // Update meta theme-color
                const meta = document.querySelector('meta[name="theme-color"]');
                if (meta) {
                    meta.content = isDark ? '#0b0f19' : '#ffffff';
                }
            }

            function cycle() {
                const current = State.get().theme;
                const next = current === 'system' ? 'dark' : current === 'dark' ? 'light' : 'system';
                State.update(s => s.theme = next);
                apply(next);
                Toast.show(`テーマ: ${next === 'system' ? 'システム設定' : next === 'dark' ? 'ダーク' : 'ライト'}`, 'info');
                return next;
            }

            function init() {
                apply(State.get().theme);

                // Listen for system theme changes
                window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
                    if (State.get().theme === 'system') {
                        apply('system');
                    }
                });
            }

            return { apply, cycle, init };
        })();

        // ===== Router =====
        const Router = (() => {
            let currentRoute = parseRoute();
            let handlers = [];

            function parseRoute() {
                const hash = location.hash || '';
                const raw = hash.startsWith('#/') ? hash.slice(2) : '';
                const [pathPart, queryPart] = raw.split('?');
                const clean = (pathPart || '').replace(/^\/+/, '');
                const parts = clean ? clean.split('/').filter(Boolean) : [];
                const params = new URLSearchParams(queryPart || '');

                const route = { name: 'home', params: {}, query: {} };
                params.forEach((v, k) => route.query[k] = v);

                if (parts.length === 0) return route;

                switch (parts[0]) {
                    case 'projects':
                        if (parts.length === 1) {
                            route.name = 'projects';
                            route.query.q = params.get('q') || '';
                            route.query.cat = params.get('cat') || '';
                        } else {
                            route.name = 'project-detail';
                            route.params.slug = parts[1];
                        }
                        break;
                    case 'apps':
                        if (parts.length === 1) {
                            route.name = 'apps';
                        } else {
                            const app = parts[1];
                            route.name = ['task', 'todo', 'pomodoro', 'ai'].includes(app)
                                ? `app-${app}`
                                : 'not-found';
                        }
                        break;
                    case 'settings':
                        route.name = 'settings';
                        break;
                    case 'about':
                        route.name = 'about';
                        break;
                    case 'resume':
                        route.name = 'resume';
                        break;
                    case 'contact':
                        route.name = 'contact';
                        break;
                    case 'quiz':
                        route.name = 'quiz';
                        break;
                    default:
                        route.name = 'not-found';
                }

                return route;
            }

            function navigate(path) {
                location.hash = '#/' + path;
            }

            function subscribe(callback) {
                handlers.push(callback);
                return () => {
                    handlers = handlers.filter(h => h !== callback);
                };
            }

            function notify() {
                const route = parseRoute();
                currentRoute = route;
                handlers.forEach(h => {
                    try { h(route); } catch (e) { console.error(e); }
                });
            }

            window.addEventListener('hashchange', notify);

            return {
                getRoute: () => currentRoute,
                navigate,
                subscribe,
                parse: parseRoute
            };
        })();

        // ===== SEO & Meta Manager =====
        const SEO = (() => {
            const titles = {
                home: 'ホーム | Portfolio',
                projects: 'プロジェクト一覧 | Portfolio',
                'project-detail': 'プロジェクト詳細 | Portfolio',
                apps: 'アプリ | Portfolio',
                'app-task': 'タスク管理 | Portfolio',
                'app-todo': 'TODOリスト | Portfolio',
                'app-pomodoro': 'ポモドーロタイマー | Portfolio',
                'app-ai': 'AIアシスト | Portfolio',
                settings: '設定 | Portfolio',
                about: 'About | Portfolio',
                resume: 'Resume | Portfolio',
                contact: 'Contact | Portfolio',
                quiz: 'AWS問題集 | Portfolio',
                'not-found': 'Not Found | Portfolio'
            };

            const descriptions = {
                home: '謙虚なITエンジニアのポートフォリオ。内蔵アプリ、整合性チェック/自動修復、セマンティックHTML5対応。',
                projects: 'プロジェクト一覧。検索/カテゴリ/タグで絞り込み、詳細（Case Study）へ。',
                apps: '内蔵アプリ（タスク管理 / TODO / ポモドーロ / ローカルAI）。',
                settings: 'Import/Export、整合性チェック/自動修復、スナップショット復元。',
                quiz: 'AWS問題集 - 模範解答についてお問い合わせください。'
            };

            function update(route) {
                const title = titles[route.name] || 'Portfolio';
                const desc = descriptions[route.name] || descriptions.home;

                document.title = title;

                // Update meta description
                let metaDesc = document.querySelector('meta[name="description"]');
                if (!metaDesc) {
                    metaDesc = document.createElement('meta');
                    metaDesc.name = 'description';
                    document.head.appendChild(metaDesc);
                }
                metaDesc.content = desc;

                // Update OG tags
                document.querySelector('meta[property="og:title"]')?.setAttribute('content', title);
                document.querySelector('meta[property="og:description"]')?.setAttribute('content', desc);

                // ARIA page announcement
                const live = document.getElementById('page-announcement');
                if (live) {
                    const pageName = titles[route.name]?.split('|')[0]?.trim() || 'ページ';
                    live.textContent = `${pageName}を読み込みました`;
                }

                // Focus management for accessibility
                const main = document.getElementById('main-content');
                if (main) {
                    main.focus({ preventScroll: true });
                }
            }

            return { update };
        })();

        // ===== v2 compatibility: setMeta (used by v2 QuizPage) =====
        function setMeta(title, desc) {
            document.title = String(title || 'Portfolio');
            if (desc) {
                let metaDesc = document.querySelector('meta[name="description"]');
                if (!metaDesc) {
                    metaDesc = document.createElement('meta');
                    metaDesc.name = 'description';
                    document.head.appendChild(metaDesc);
                }
                metaDesc.setAttribute('content', String(desc));
                // keep OG/Twitter in sync (best-effort)
                document.querySelector('meta[property="og:title"]')?.setAttribute('content', String(title || 'Portfolio'));
                document.querySelector('meta[property="og:description"]')?.setAttribute('content', String(desc));
                document.querySelector('meta[name="twitter:title"]')?.setAttribute('content', String(title || 'Portfolio'));
                document.querySelector('meta[name="twitter:description"]')?.setAttribute('content', String(desc));
            }
        }


        // ===== Component: Sidebar =====
        function Sidebar(isDrawer = false) {
            const state = State.get();
            const route = Router.getRoute();

            const navItems = [
                { icon: 'home', label: 'ホーム', path: '', active: route.name === 'home' },
                { icon: 'briefcase', label: 'プロジェクト', path: 'projects', active: route.name.startsWith('project') },
                { icon: 'apps', label: 'アプリ', path: 'apps', active: route.name === 'apps' },
            ];

            const appItems = [
                { icon: 'checkSquare', label: 'タスク管理', path: 'apps/task', active: route.name === 'app-task' },
                { icon: 'list', label: 'クイックTODO', path: 'apps/todo', active: route.name === 'app-todo' },
                { icon: 'clock', label: 'ポモドーロ', path: 'apps/pomodoro', active: route.name === 'app-pomodoro' },
                { icon: 'brain', label: 'AI アシスト', path: 'apps/ai', active: route.name === 'app-ai' },
            ];

            const infoItems = [
                { icon: 'user', label: 'About', path: 'about', active: route.name === 'about' },
                { icon: 'briefcase', label: 'Resume', path: 'resume', active: route.name === 'resume' },
                { icon: 'mail', label: 'Contact', path: 'contact', active: route.name === 'contact' },
            ];

            const quizItems = [
                { icon: 'briefcase', label: 'AWS', path: 'quiz?type=aws', active: route.name === 'quiz' && (!route.query.type || route.query.type === 'aws') },
                { icon: 'briefcase', label: 'PM', path: 'quiz?type=pm', active: route.name === 'quiz' && route.query.type === 'pm' },
                { icon: 'briefcase', label: '品質・プロセス', path: 'quiz?type=quality', active: route.name === 'quiz' && route.query.type === 'quality' },
            ];

            const systemItems = [
                { icon: 'settings', label: '設定・データ', path: 'settings', active: route.name === 'settings' },
            ];

            function navLink(item) {
                return h('button', {
                    class: ['nav-link', item.active && 'active'],
                    onclick: () => {
                        Router.navigate(item.path);
                        if (isDrawer) {
                            document.getElementById('drawer').style.display = 'none';
                            document.getElementById('overlay').style.display = 'none';
                        }
                    },
                    'aria-current': item.active ? 'page' : undefined
                },
                    createIcon(item.icon),
                    h('span', { text: item.label })
                );
            }

            const content = h('div', { class: 'flex flex-col gap-2' },
                h('div', { class: 'flex items-center justify-between mb-4' },
                    h('div', { class: 'flex flex-col' },
                        h('div', { class: 'h4' }, 'Portfolio'),
                        h('div', { class: 'text-small text-muted' }, state.profile.title)
                    ),
                    isDrawer ? h('button', {
                        class: 'icon-btn',
                        onclick: () => {
                            document.getElementById('drawer').style.display = 'none';
                            document.getElementById('overlay').style.display = 'none';
                        },
                        'aria-label': '閉じる'
                    }, createIcon('x')) : null
                ),
                h('div', { class: 'divider' }),
                ...navItems.map(navLink),
                h('div', { class: 'nav-title' }, 'Apps'),
                ...appItems.map(navLink),
                h('div', { class: 'nav-title' }, '問題集'),
                ...quizItems.map(navLink),
                h('div', { class: 'nav-title' }, 'Info'),
                ...infoItems.map(navLink),
                h('div', { class: 'nav-title' }, 'System'),
                ...systemItems.map(navLink),
                h('div', { class: 'divider' }),
                h('div', { class: 'flex items-center justify-between p-3 rounded-lg' },
                    h('div', { class: 'flex flex-col' },
                        h('div', { class: 'text-xs text-muted' }, 'テーマ'),
                        h('div', { class: 'text-small font-semibold' },
                            state.theme === 'system' ? 'システム' : state.theme === 'dark' ? 'ダーク' : 'ライト'
                        )
                    ),
                    h('button', {
                        class: 'icon-btn',
                        onclick: Theme.cycle,
                        'aria-label': 'テーマを切り替え'
                    }, createIcon(state.theme === 'dark' || (state.theme === 'system' && window.matchMedia('(prefers-color-scheme: dark)').matches) ? 'sun' : 'moon'))
                )
            );

            return content;
        }

        // ===== Component: Home Page =====
        function HomePage() {
            const state = State.get();
            const featured = state.projects.find(p => p.demoRoute === 'task') || state.projects[0];

            return h('div', { class: 'flex flex-col gap-6' },
                // Hero Section
                h('article', { class: 'card' },
                    h('div', { class: 'card-body' },
                        h('header', {},
                            h('h1', { class: 'h1 mb-4' }, `${state.profile.title} のポートフォリオ`)
                        ),
                        h('p', { class: 'text-muted', style: { whiteSpace: 'pre-wrap', lineHeight: '1.8' } }, state.profile.bio),
                        h('div', { class: 'flex flex-wrap gap-3 mt-6' },
                            h('button', {
                                class: 'btn btn-primary',
                                onclick: () => Router.navigate('projects')
                            }, 'プロジェクトを見る'),
                            h('button', {
                                class: 'btn btn-secondary',
                                onclick: () => Router.navigate('apps')
                            }, 'アプリを見る'),
                            h('button', {
                                class: 'btn btn-ghost',
                                onclick: () => Router.navigate('settings')
                            }, '設定・データ')
                        )
                    )
                ),

                // Featured Project
                h('div', { class: 'grid grid-cols-2' },
                    h('article', { class: 'card' },
                        h('div', { class: 'card-body' },
                            h('h3', { class: 'h3 mb-3' }, '注目のプロジェクト'),
                            h('div', { class: 'flex gap-2 mb-3' },
                                h('span', { class: 'badge badge-primary' }, featured.category),
                                featured.demoRoute ? h('span', { class: 'badge badge-success' }, 'デモあり') : null
                            ),
                            h('p', { class: 'text-muted mb-4' }, featured.name),
                            h('p', { class: 'text-small text-muted' }, featured.summary),
                            h('div', { class: 'flex gap-2 mt-4' },
                                h('button', {
                                    class: 'btn btn-ghost btn-sm',
                                    onclick: () => Router.navigate(`projects/${featured.slug}`)
                                }, '詳細 →'),
                                featured.demoRoute ? h('button', {
                                    class: 'btn btn-secondary btn-sm',
                                    onclick: () => Router.navigate(`apps/${featured.demoRoute}`)
                                }, 'デモ起動') : null
                            )
                        )
                    ),

                    h('article', { class: 'card' },
                        h('div', { class: 'card-body' },
                            h('h3', { class: 'h3 mb-3' }, '設計上の工夫'),
                            h('ul', {
                                class: 'text-muted',
                                style: { paddingLeft: '1.5rem', lineHeight: '2' }
                            },
                                h('li', {}, 'Importは検証＋正規化＋衝突モード'),
                                h('li', {}, '整合性チェック→自動修復（重複/孤立/無効URL等）'),
                                h('li', {}, 'スナップショット→復元で最短復旧'),
                                h('li', {}, 'セマンティックHTML5 + ARIA対応'),
                                h('li', {}, '単一HTMLで完結（依存性最小化）')
                            )
                        )
                    )
                ),

                // Stats
                h('section', { class: 'grid grid-cols-3' },
                    h('div', { class: 'card' },
                        h('div', { class: 'card-body text-center' },
                            h('div', { class: 'h2', style: { color: 'var(--color-primary)' } }, String(state.projects.length)),
                            h('div', { class: 'text-small text-muted' }, 'プロジェクト')
                        )
                    ),
                    h('div', { class: 'card' },
                        h('div', { class: 'card-body text-center' },
                            h('div', { class: 'h2', style: { color: 'var(--color-success)' } }, String(state.appsData.tasks.length)),
                            h('div', { class: 'text-small text-muted' }, 'タスク')
                        )
                    ),
                    h('div', { class: 'card' },
                        h('div', { class: 'card-body text-center' },
                            h('div', { class: 'h2', style: { color: 'var(--color-warning)' } }, String(state.appsData.todos.length)),
                            h('div', { class: 'text-small text-muted' }, 'TODO')
                        )
                    )
                )
            );
        }

        // ===== Component: Projects Page =====
        function ProjectsPage() {
            const state = State.get();
            const route = Router.getRoute();
            let q = route.query.q || '';
            let cat = route.query.cat || 'All';

            const categories = ['All', ...new Set(state.projects.map(p => p.category))];

            // Tokenize and score
            function tokenize(s) {
                return String(s || '').toLowerCase().split(/[\s\-_\/\.,:;()\[\]{}"']+/).filter(Boolean);
            }

            function scoreProject(p, tokens) {
                if (!tokens.length) return 1;
                const corpus = [
                    ...tokenize(p.name),
                    ...tokenize(p.summary),
                    ...(p.tags || []).map(t => String(t).toLowerCase()),
                    ...(p.tech || []).map(t => String(t).toLowerCase()),
                    ...tokenize(p.category)
                ];

                const freq = new Map();
                corpus.forEach(w => freq.set(w, (freq.get(w) || 0) + 1));

                let score = 0;
                tokens.forEach(t => {
                    if (freq.has(t)) score += 5 + Math.min(3, freq.get(t));
                    corpus.forEach(w => {
                        if (w.includes(t) && w !== t) score += 1;
                    });
                });
                return score;
            }

            function getFilteredProjects() {
                let list = state.projects.slice();



                // Hide projects (Settings -> projectPrefs.hiddenIds)
                const hiddenIds = new Set(((state.projectPrefs && state.projectPrefs.hiddenIds) || []).map(String));
                if (hiddenIds.size) list = list.filter(p => !hiddenIds.has(p.id));

                if (cat !== 'All') {
                    list = list.filter(p => p.category === cat);
                }

                const tokens = tokenize(q);
                if (tokens.length) {
                    list = list
                        .map(p => ({ p, s: scoreProject(p, tokens) }))
                        .filter(x => x.s > 0)
                        .sort((a, b) => b.s - a.s)
                        .map(x => x.p);
                }

                return list;
            }

            function updateSearch(newQ, newCat) {
                q = newQ;
                cat = newCat;
                const params = new URLSearchParams();
                if (q) params.set('q', q);
                if (cat !== 'All') params.set('cat', cat);
                Router.navigate('projects' + (params.toString() ? '?' + params.toString() : ''));
                render();
            }

            function render() {
                const container = document.createElement('div');
                container.className = 'flex flex-col gap-6';

                // Header
                container.appendChild(h('header', {},
                    h('div', { class: 'flex flex-wrap items-center justify-between gap-4 mb-4' },
                        h('div', {},
                            h('h1', { class: 'h1' }, 'プロジェクト一覧'),
                            h('p', { class: 'text-muted' }, `合計 ${getFilteredProjects().length} 件`)
                        )
                    ),
                    h('div', { class: 'grid grid-cols-2 gap-4' },
                        h('div', { class: 'relative' },
                            h('div', {
                                class: 'absolute left-3 top-1/2 transform -translate-y-1/2',
                                style: { color: 'var(--text-muted)' }
                            }, createIcon('search', 18)),
                            h('input', {
                                class: 'input pl-10',
                                placeholder: '検索（名前/概要/タグ/技術/カテゴリ）...',
                                value: q,
                                oninput: (e) => updateSearch(e.target.value, cat)
                            })
                        ),
                        h('select', {
                            class: 'input',
                            value: cat,
                            onchange: (e) => updateSearch(q, e.target.value)
                        },
                            ...categories.map(c => h('option', {
                                value: c,
                                text: c === 'All' ? '全カテゴリー' : c
                            }))
                        )
                    )
                ));

                // Project Grid
                const projects = getFilteredProjects();
                const grid = h('div', { class: 'grid grid-cols-3', style: { gap: '1.5rem' } });

                if (projects.length === 0) {
                    grid.appendChild(h('div', {
                        class: 'card',
                        style: { gridColumn: '1/-1' }
                    },
                        h('div', { class: 'card-body text-center text-muted' },
                            '条件に一致するプロジェクトはありません。'
                        )
                    ));
                } else {
                    projects.forEach(p => {
                        const card = h('article', { class: 'card', style: { display: 'flex', flexDirection: 'column' } },
                            h('div', { class: 'card-body', style: { flex: '1', display: 'flex', flexDirection: 'column' } },
                                h('div', { class: 'flex flex-wrap gap-2 mb-3' },
                                    h('span', { class: 'badge badge-primary' }, p.category),
                                    p.demoRoute ? h('span', { class: 'badge badge-success' }, 'デモあり') : null
                                ),
                                h('h3', { class: 'h3 mb-2' }, p.name),
                                h('p', { class: 'text-small text-muted mb-3' }, p.summary),
                                h('div', { class: 'flex flex-wrap gap-2 mb-4' },
                                    ...(p.tags || []).slice(0, 4).map(tag =>
                                        h('button', {
                                            class: 'badge badge-secondary',
                                            onclick: () => updateSearch(tag, 'All')
                                        }, '#' + tag)
                                    )
                                ),
                                h('div', { class: 'flex gap-2 mt-auto' },
                                    p.demoRoute ? h('button', {
                                        class: 'btn btn-secondary btn-sm',
                                        onclick: () => Router.navigate(`apps/${p.demoRoute}`)
                                    }, 'デモ') : null,
                                    h('button', {
                                        class: 'btn btn-ghost btn-sm',
                                        onclick: () => Router.navigate(`projects/${p.slug}`)
                                    }, '詳細を見る')
                                )
                            )
                        );
                        grid.appendChild(card);
                    });
                }

                container.appendChild(grid);
                return container;
            }

            return render();
        }

        // ===== Component: Project Detail Page =====
        function ProjectDetailPage(slug) {
            const state = State.get();
            const project = state.projects.find(p => p.slug === slug);

            if (!project) {
                return h('div', { class: 'flex flex-col gap-4' },
                    h('h1', { class: 'h1' }, 'プロジェクトが見つかりません'),
                    h('button', {
                        class: 'btn btn-secondary',
                        onclick: () => Router.navigate('projects')
                    }, '一覧へ戻る')
                );
            }

            const related = state.projects.filter(p =>
                project.relatedProjectIds?.includes(p.id) && p.id !== project.id
            );



            const autoRelated = autoRelatedCandidatesV10(project, state.projects, 8);
            return h('article', { class: 'flex flex-col gap-6' },
                // Header
                h('header', {},
                    h('button', {
                        class: 'btn btn-ghost btn-sm mb-4',
                        onclick: () => Router.navigate('projects')
                    }, '← 一覧に戻る'),
                    h('div', { class: 'flex flex-wrap gap-2 mb-3' },
                        h('span', { class: 'badge badge-primary' }, project.category),
                        project.demoRoute ? h('span', { class: 'badge badge-success' }, 'デモあり') : null
                    ),
                    h('h1', { class: 'h1 mb-3' }, project.name),
                    h('p', { class: 'text-muted mb-4' }, project.summary),
                    h('div', { class: 'flex flex-wrap gap-2' },
                        ...(project.tags || []).map(tag =>
                            h('span', { class: 'badge badge-secondary' }, '#' + tag)
                        )
                    )
                ),

                // Content Grid
                h('div', { class: 'grid grid-cols-2', style: { gap: '1.5rem', alignItems: 'start' } },
                    // Left Column
                    h('div', { class: 'flex flex-col gap-4' },
                        h('section', { class: 'card' },
                            h('div', { class: 'card-body' },
                                h('h3', { class: 'h3 mb-3' }, h('div', { class: 'flex items-center gap-2' },
                                    createIcon('alert', 20),
                                    '課題'
                                )),
                                h('p', { class: 'text-muted', style: { whiteSpace: 'pre-wrap' } }, project.problem)
                            )
                        ),
                        h('section', { class: 'card' },
                            h('div', { class: 'card-body' },
                                h('h3', { class: 'h3 mb-3' }, h('div', { class: 'flex items-center gap-2' },
                                    createIcon('brain', 20),
                                    'アプローチ'
                                )),
                                h('p', { class: 'text-muted', style: { whiteSpace: 'pre-wrap' } }, project.approach)
                            )
                        ),
                        h('section', { class: 'card' },
                            h('div', { class: 'card-body' },
                                h('h3', { class: 'h3 mb-3' }, h('div', { class: 'flex items-center gap-2' },
                                    createIcon('apps', 20),
                                    'アーキテクチャ'
                                )),
                                h('p', { class: 'text-muted font-mono text-small', style: { whiteSpace: 'pre-wrap' } },
                                    project.architecture?.overview || '(未登録)'
                                )
                            )
                        )
                    ),

                    // Right Column
                    h('div', { class: 'flex flex-col gap-4' },
                        h('section', { class: 'card' },
                            h('div', { class: 'card-body' },
                                h('h3', { class: 'h3 mb-3' }, '使用技術'),
                                h('div', { class: 'flex flex-wrap gap-2' },
                                    ...(project.tech || []).map(t =>
                                        h('span', { class: 'badge badge-secondary' }, t)
                                    )
                                )
                            )
                        ),
                        project.demoRoute ? h('section', {
                            class: 'card',
                            style: { borderColor: 'var(--color-primary)', background: 'rgba(var(--color-primary-rgb),0.05)' }
                        },
                            h('div', { class: 'card-body' },
                                h('h3', { class: 'h3 mb-2' }, 'デモ'),
                                h('p', { class: 'text-small text-muted mb-3' }, 'このプロジェクトはポートフォリオ内で実際に動作します。'),
                                h('button', {
                                    class: 'btn btn-primary',
                                    onclick: () => Router.navigate(`apps/${project.demoRoute}`)
                                }, 'アプリを起動')
                            )
                        ) : null,
                        related.length > 0 ? h('section', { class: 'card' },
                            h('div', { class: 'card-body' },
                                h('h3', { class: 'h3 mb-3' }, '関連プロジェクト'),
                                h('ul', { style: { listStyle: 'none', padding: '0' } },
                                    ...related.map(r =>
                                        h('li', { class: 'mb-2' },
                                            h('button', {
                                                class: 'btn btn-ghost btn-sm',
                                                onclick: () => Router.navigate(`projects/${r.slug}`)
                                            }, r.name)
                                        )
                                    )
                                )
                            )
                        ) : null
                    )
                ),

                // Metrics
                h('section', { class: 'card' },
                    h('div', { class: 'card-body' },
                        h('h3', { class: 'h3 mb-4' }, 'メトリクス'),
                        project.outcome?.metrics?.length ? h('div', { class: 'grid grid-cols-3' },
                            ...project.outcome.metrics.map(m =>
                                h('div', { class: 'text-center p-4' },
                                    h('div', {
                                        class: 'h2 mb-1',
                                        style: { color: 'var(--color-primary)' }
                                    }, m.value),
                                    h('div', { class: 'text-small text-muted' }, m.label)
                                )
                            )
                        ) : h('p', { class: 'text-muted' }, 'メトリクスは未登録です。')
                    )
                )

                ,
                autoRelated.length > 0 ? h('section', { class: 'card' },
                    h('div', { class: 'card-body' },
                        h('h3', { class: 'h3 mb-3' }, 'おすすめ（自動）'),
                        h('p', { class: 'text-muted mb-3' }, 'カテゴリ/タグ/技術/本文の近さから自動で近いプロジェクトを提案します。'),
                        h('ul', { style: { listStyle: 'none', padding: '0', margin: '0' } },
                            ...autoRelated.map(r =>
                                h('li', { class: 'mb-2' },
                                    h('button', {
                                        class: 'btn btn-ghost btn-sm',
                                        onclick: () => Router.navigate(`projects/${r.slug}`)
                                    },
                                        createIcon('sparkles', 16),
                                        h('span', { style: { marginLeft: '8px' } }, r.name)
                                    )
                                )
                            )
                        )
                    )
                ) : null);
        }

        // ===== Component: Apps Hub =====
        function AppsPage() {
            const apps = [
                { id: 'task', title: 'タスク管理', desc: 'カンバン形式の簡易タスク管理', icon: 'checkSquare' },
                { id: 'todo', title: 'クイックTODO', desc: 'クイック入力 + 完了管理', icon: 'list' },
                { id: 'pomodoro', title: 'ポモドーロ', desc: '耐タブ休眠のタイマー + フォーカス対象', icon: 'clock' },
                { id: 'ai', title: 'AI アシスト', desc: 'ローカルAI（外部API不要）', icon: 'brain' },
            ];

            return h('div', { class: 'flex flex-col gap-6' },
                h('header', {},
                    h('h1', { class: 'h1' }, 'アプリ'),
                    h('p', { class: 'text-muted' }, 'ポートフォリオに内蔵された実用的なツール')
                ),
                h('div', { class: 'grid grid-cols-2' },
                    ...apps.map(app =>
                        h('article', { class: 'card' },
                            h('div', { class: 'card-body' },
                                h('div', { class: 'flex items-center gap-3 mb-3' },
                                    createIcon(app.icon, 24),
                                    h('h3', { class: 'h3' }, app.title)
                                ),
                                h('p', { class: 'text-muted mb-4' }, app.desc),
                                h('button', {
                                    class: 'btn btn-secondary',
                                    onclick: () => Router.navigate(`apps/${app.id}`)
                                }, '開く')
                            )
                        )
                    )
                )
            );
        }

        // ===== Component: Task App =====
        function TaskPage() {
            let filter = { q: '', priority: 'all' };

            function addTask(title) {
                if (!title.trim()) return;
                State.update(s => {
                    s.appsData.tasks.unshift({
                        id: uid(),
                        title: title.trim().slice(0, CONSTANTS.LIMITS.TASK_TITLE),
                        status: 'backlog',
                        priority: 'med',
                        tags: [],
                        createdAt: Date.now(),
                        updatedAt: Date.now()
                    });
                });
                Toast.show('タスクを追加しました', 'success');
            }

            function updateTask(id, updates) {
                State.update(s => {
                    const task = s.appsData.tasks.find(t => t.id === id);
                    if (task) {
                        Object.assign(task, updates, { updatedAt: Date.now() });
                    }
                });
            }

            function deleteTask(id) {
                State.update(s => {
                    s.appsData.tasks = s.appsData.tasks.filter(t => t.id !== id);
                    if (s.appsData.pomodoro.runtime.linkedTaskId === id) {
                        s.appsData.pomodoro.runtime.linkedTaskId = null;
                    }
                });
                Toast.show('タスクを削除しました', 'success');
            }

            function moveStatus(task, direction) {
                const statuses = ['backlog', 'in-progress', 'done'];
                const idx = statuses.indexOf(task.status);
                const newIdx = clamp(idx + direction, 0, statuses.length - 1);
                if (newIdx !== idx) {
                    updateTask(task.id, { status: statuses[newIdx] });
                }
            }

            function getFilteredTasks() {
                return State.get().appsData.tasks.filter(t => {
                    const matchesQ = !filter.q ||
                        t.title.toLowerCase().includes(filter.q.toLowerCase()) ||
                        t.tags.some(tag => tag.toLowerCase().includes(filter.q.toLowerCase()));
                    const matchesPriority = filter.priority === 'all' || t.priority === filter.priority;
                    return matchesQ && matchesPriority;
                });
            }

            function render() {
                const container = document.createElement('div');
                container.className = 'flex flex-col gap-4';

                // Header
                container.appendChild(h('header', {},
                    h('div', { class: 'flex items-center gap-3 mb-4' },
                        createIcon('checkSquare', 28),
                        h('h1', { class: 'h1' }, 'タスク管理')
                    ),
                    h('div', { class: 'grid grid-cols-2 gap-4' },
                        h('input', {
                            class: 'input',
                            placeholder: '新しいタスクを入力...',
                            onkeydown: (e) => {
                                if (e.key === 'Enter') {
                                    addTask(e.target.value);
                                    e.target.value = '';
                                }
                            }
                        }),
                        h('select', {
                            class: 'input',
                            value: filter.priority,
                            onchange: (e) => {
                                filter.priority = e.target.value;
                                render();
                            }
                        },
                            h('option', { value: 'all', text: '優先度: 全て' }),
                            h('option', { value: 'high', text: 'High' }),
                            h('option', { value: 'med', text: 'Med' }),
                            h('option', { value: 'low', text: 'Low' })
                        )
                    )
                ));

                // Kanban
                const statuses = [
                    { id: 'backlog', label: '未着手' },
                    { id: 'in-progress', label: '進行中' },
                    { id: 'done', label: '完了' }
                ];

                const allTasks = getFilteredTasks();

                const board = h('div', {
                    class: 'grid grid-cols-3',
                    style: { gap: '1rem', minHeight: '400px' }
                });

                statuses.forEach(col => {
                    const tasks = allTasks.filter(t => t.status === col.id);
                    const column = h('section', {
                        class: 'card',
                        style: { background: 'var(--bg-secondary)' }
                    },
                        h('div', { class: 'card-header' },
                            h('div', { class: 'flex items-center justify-between' },
                                h('h4', { class: 'h4' }, col.label),
                                h('span', { class: 'badge badge-secondary' }, String(tasks.length))
                            )
                        ),
                        h('div', { class: 'card-body flex flex-col gap-3' },
                            ...tasks.map(task =>
                                h('article', {
                                    class: 'card',
                                    style: { background: 'var(--surface)' }
                                },
                                    h('div', { class: 'p-3' },
                                        h('div', { class: 'flex items-start justify-between gap-2 mb-2' },
                                            h('div', { class: 'flex items-center gap-2' },
                                                h('span', {
                                                    class: 'w-2 h-2 rounded-full',
                                                    style: `background:${task.priority === 'high' ? 'var(--color-danger)' :
                                                            task.priority === 'med' ? 'var(--color-warning)' :
                                                                'var(--color-success)'
                                                        };`
                                                }),
                                                h('span', { class: 'font-medium text-small' }, task.title)
                                            ),
                                            h('button', {
                                                class: 'icon-btn btn-sm',
                                                style: { width: '1.5rem', height: '1.5rem' },
                                                onclick: () => deleteTask(task.id)
                                            }, createIcon('trash', 14))
                                        ),
                                        h('div', { class: 'flex items-center justify-between' },
                                            h('select', {
                                                class: 'input btn-sm',
                                                style: 'width:auto;padding:0.25rem 0.5rem;font-size:0.75rem;',
                                                value: task.priority,
                                                onchange: (e) => updateTask(task.id, { priority: e.target.value })
                                            },
                                                h('option', { value: 'high', text: 'High' }),
                                                h('option', { value: 'med', text: 'Med' }),
                                                h('option', { value: 'low', text: 'Low' })
                                            ),
                                            h('div', { class: 'flex gap-1' },
                                                h('button', {
                                                    class: 'btn btn-ghost btn-sm',
                                                    disabled: task.status === 'backlog',
                                                    onclick: () => moveStatus(task, -1)
                                                }, '←'),
                                                h('button', {
                                                    class: 'btn btn-ghost btn-sm',
                                                    disabled: task.status === 'done',
                                                    onclick: () => moveStatus(task, 1)
                                                }, '→')
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    );
                    board.appendChild(column);
                });

                container.appendChild(board);
                return container;
            }

            return render();
        }

        // ===== Component: Todo App =====
        function TodoPage() {
            let filter = 'all';
            let composing = false;

            function addTodo(text) {
                if (!text.trim()) return;
                State.update(s => {
                    s.appsData.todos.unshift({
                        id: uid(),
                        text: text.trim().slice(0, CONSTANTS.LIMITS.TODO_TEXT),
                        completed: false,
                        createdAt: Date.now(),
                        dueDate: null
                    });
                });
            }

            function toggleTodo(id) {
                State.update(s => {
                    const todo = s.appsData.todos.find(t => t.id === id);
                    if (todo) todo.completed = !todo.completed;
                });
            }

            function deleteTodo(id) {
                State.update(s => {
                    s.appsData.todos = s.appsData.todos.filter(t => t.id !== id);
                });
            }

            function clearCompleted() {
                State.update(s => {
                    s.appsData.todos = s.appsData.todos.filter(t => !t.completed);
                });
                Toast.show('完了済みを削除しました', 'success');
            }

            const todos = State.get().appsData.todos;
            const filtered = todos.filter(t => {
                if (filter === 'active') return !t.completed;
                if (filter === 'completed') return t.completed;
                return true;
            });

            return h('div', { class: 'flex flex-col gap-4 max-w-2xl' },
                h('header', { class: 'flex items-center gap-3' },
                    createIcon('list', 28),
                    h('h1', { class: 'h1' }, 'クイックTODO')
                ),

                h('section', { class: 'card' },
                    h('div', { class: 'card-body' },
                        h('input', {
                            class: 'input',
                            placeholder: '入力してEnter（IME対応）...',
                            oncompositionstart: () => composing = true,
                            oncompositionend: () => composing = false,
                            onkeydown: (e) => {
                                if (e.key === 'Enter' && !composing) {
                                    addTodo(e.target.value);
                                    e.target.value = '';
                                }
                            }
                        }),
                        h('div', { class: 'flex gap-2 mt-4' },
                            h('select', {
                                class: 'input',
                                style: { width: 'auto' },
                                value: filter,
                                onchange: (e) => render()
                            },
                                h('option', { value: 'all', text: '全て' }),
                                h('option', { value: 'active', text: '未完了' }),
                                h('option', { value: 'completed', text: '完了' })
                            ),
                            h('button', {
                                class: 'btn btn-secondary btn-sm',
                                disabled: !todos.some(t => t.completed),
                                onclick: clearCompleted
                            }, '完了済み削除')
                        )
                    )
                ),

                h('section', { class: 'flex flex-col gap-2' },
                    ...filtered.map(todo =>
                        h('article', { class: 'card' },
                            h('div', { class: 'card-body flex items-center gap-3' },
                                h('input', {
                                    type: 'checkbox',
                                    checked: todo.completed,
                                    onchange: () => toggleTodo(todo.id),
                                    'aria-label': todo.completed ? '未完了に戻す' : '完了にする'
                                }),
                                h('span', {
                                    class: ['flex-1', todo.completed && 'text-muted'],
                                    style: todo.completed ? 'text-decoration:line-through;opacity:0.6;' : undefined
                                }, todo.text),
                                h('button', {
                                    class: 'icon-btn',
                                    onclick: () => deleteTodo(todo.id),
                                    'aria-label': '削除'
                                }, createIcon('x', 16))
                            )
                        )
                    ),
                    filtered.length === 0 && h('p', { class: 'text-muted text-center py-8' }, 'TODOはありません。')
                )
            );
        }

        // ===== Component: Pomodoro App =====
        let pomodoroTimer = null;

        function PomodoroPage() {
            const pomo = State.get().appsData.pomodoro;

            function formatTime(sec) {
                const m = Math.floor(sec / 60);
                const s = sec % 60;
                return `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
            }

            function getDuration(mode) {
                return (mode === 'work' ? pomo.settings.work :
                    mode === 'short-break' ? pomo.settings.short : pomo.settings.long) * 60;
            }

            function getRemaining() {
                const rt = pomo.runtime;
                if (rt.isActive && rt.endAtMs) {
                    return Math.max(0, Math.ceil((rt.endAtMs - Date.now()) / 1000));
                }
                return rt.remainingSec;
            }

            function start() {
                const remaining = getRemaining();
                State.update(s => {
                    s.appsData.pomodoro.runtime.isActive = true;
                    s.appsData.pomodoro.runtime.endAtMs = Date.now() + remaining * 1000;
                });
                startTimer();
            }

            function pause() {
                State.update(s => {
                    s.appsData.pomodoro.runtime.isActive = false;
                    s.appsData.pomodoro.runtime.endAtMs = null;
                    s.appsData.pomodoro.runtime.remainingSec = getRemaining();
                });
                stopTimer();
            }

            function reset() {
                stopTimer();
                const duration = getDuration(pomo.runtime.mode);
                State.update(s => {
                    s.appsData.pomodoro.runtime.isActive = false;
                    s.appsData.pomodoro.runtime.endAtMs = null;
                    s.appsData.pomodoro.runtime.remainingSec = duration;
                });
            }

            function complete() {
                stopTimer();
                const duration = getDuration(pomo.runtime.mode);
                State.update(s => {
                    s.appsData.pomodoro.history.push({
                        timestamp: Date.now(),
                        durationMinutes: Math.floor(duration / 60),
                        type: s.appsData.pomodoro.runtime.mode,
                        linkedTaskId: s.appsData.pomodoro.runtime.linkedTaskId
                    });
                    s.appsData.pomodoro.history = s.appsData.pomodoro.history.slice(-200);
                    s.appsData.pomodoro.runtime.isActive = false;
                    s.appsData.pomodoro.runtime.endAtMs = null;
                    s.appsData.pomodoro.runtime.remainingSec = duration;
                });
                Toast.show('セッション完了！', 'success');
            }

            function switchMode(mode) {
                stopTimer();
                const duration = getDuration(mode);
                State.update(s => {
                    s.appsData.pomodoro.runtime.mode = mode;
                    s.appsData.pomodoro.runtime.isActive = false;
                    s.appsData.pomodoro.runtime.endAtMs = null;
                    s.appsData.pomodoro.runtime.remainingSec = duration;
                });
            }

            function startTimer() {
                if (pomodoroTimer) clearInterval(pomodoroTimer);
                pomodoroTimer = setInterval(() => {
                    const remaining = getRemaining();
                    if (remaining <= 0) {
                        complete();
                    }
                    render();
                }, 1000);
            }

            function stopTimer() {
                if (pomodoroTimer) {
                    clearInterval(pomodoroTimer);
                    pomodoroTimer = null;
                }
            }

            // Cleanup on unmount
            Router.subscribe(() => stopTimer());

            const modes = [
                { id: 'work', label: '集中' },
                { id: 'short-break', label: '短休憩' },
                { id: 'long-break', label: '長休憩' }
            ];

            const remaining = getRemaining();
            const isActive = pomo.runtime.isActive;

            function render() {
                return h('div', { class: 'flex flex-col gap-4 max-w-xl' },
                    h('header', { class: 'flex items-center gap-3' },
                        createIcon('clock', 28),
                        h('h1', { class: 'h1' }, 'ポモドーロタイマー')
                    ),

                    // Timer Display
                    h('section', { class: 'card' },
                        h('div', { class: 'card-body text-center' },
                            h('div', { class: 'flex justify-center gap-2 mb-6' },
                                ...modes.map(m =>
                                    h('button', {
                                        class: ['btn', pomo.runtime.mode === m.id ? 'btn-primary' : 'btn-secondary'],
                                        onclick: () => switchMode(m.id)
                                    }, m.label)
                                )
                            ),
                            h('div', {
                                class: 'font-mono mb-6',
                                style: { fontSize: '4rem', fontWeight: '800', letterSpacing: '-0.02em' }
                            }, formatTime(remaining)),
                            h('div', { class: 'flex justify-center gap-3' },
                                h('button', {
                                    class: 'btn btn-primary btn-lg',
                                    onclick: isActive ? pause : start
                                }, isActive ? h('span', {}, createIcon('pause', 20), ' 一時停止') : h('span', {}, createIcon('play', 20), ' 開始')),
                                h('button', {
                                    class: 'btn btn-secondary',
                                    onclick: reset,
                                    'aria-label': 'リセット'
                                }, createIcon('rotate', 20))
                            )
                        )
                    ),

                    // Settings
                    h('section', { class: 'card' },
                        h('div', { class: 'card-body' },
                            h('h3', { class: 'h3 mb-4' }, '設定（分）'),
                            h('div', { class: 'grid grid-cols-3 gap-4' },
                                h('div', {},
                                    h('label', { class: 'text-small text-muted mb-1 block' }, '集中'),
                                    h('input', {
                                        type: 'number',
                                        class: 'input',
                                        value: pomo.settings.work,
                                        min: 1, max: 180,
                                        onchange: (e) => State.update(s => {
                                            s.appsData.pomodoro.settings.work = clamp(parseInt(e.target.value) || 25, 1, 180);
                                            if (!s.appsData.pomodoro.runtime.isActive && s.appsData.pomodoro.runtime.mode === 'work') {
                                                s.appsData.pomodoro.runtime.remainingSec = s.appsData.pomodoro.settings.work * 60;
                                            }
                                        })
                                    })
                                ),
                                h('div', {},
                                    h('label', { class: 'text-small text-muted mb-1 block' }, '短休憩'),
                                    h('input', {
                                        type: 'number',
                                        class: 'input',
                                        value: pomo.settings.short,
                                        min: 1, max: 60,
                                        onchange: (e) => State.update(s => {
                                            s.appsData.pomodoro.settings.short = clamp(parseInt(e.target.value) || 5, 1, 60);
                                        })
                                    })
                                ),
                                h('div', {},
                                    h('label', { class: 'text-small text-muted mb-1 block' }, '長休憩'),
                                    h('input', {
                                        type: 'number',
                                        class: 'input',
                                        value: pomo.settings.long,
                                        min: 1, max: 120,
                                        onchange: (e) => State.update(s => {
                                            s.appsData.pomodoro.settings.long = clamp(parseInt(e.target.value) || 15, 1, 120);
                                        })
                                    })
                                )
                            )
                        )
                    )
                );
            }

            return render();
        }

        // ===== Component: AI Assist Page =====
        function AIPage() {
            const ai = State.get().appsData.ai;
            let loading = false;

            function analyzeInput(input) {
                const p = input.toLowerCase();
                if (p.includes('エラー') || p.includes('バグ') || p.includes('失敗')) return 'troubleshoot';
                if (p.includes('設計') || p.includes('計画') || p.includes('構成')) return 'design';
                return 'general';
            }

            function generateResponse(input, type) {
                if (type === 'troubleshoot') {
                    return `[AI分析: トラブルシューティング]
• 再現条件を明確化
• 影響範囲を特定
• ログ/証跡を収集
• 切り分けを実施
• 修正と回帰テスト

詳細な手順が必要であれば、「具体的なエラー内容を教えてください」とお伝えください。`;
                }
                if (type === 'design') {
                    return `[AI分析: 設計支援]
• 目的と非目的の定義
• 依存関係と制約の整理
• 失敗条件の洗い出し
• 境界（責任/権限）の明確化
• 検証手段の設計

設計書のテンプレートが必要であればお知らせください。`;
                }
                return `[AI分析: 一般支援]
タスク分解、文章生成、ポートフォリオ作成支援などに対応しています。
具体的なご質問をお聞かせください。`;
            }

            function submit(input) {
                if (!input.trim() || loading) return;
                loading = true;

                const type = analyzeInput(input);

                setTimeout(() => {
                    const response = generateResponse(input, type);
                    State.update(s => {
                        s.appsData.ai.history.push({
                            prompt: input,
                            response,
                            timestamp: Date.now()
                        });
                        s.appsData.ai.history = s.appsData.ai.history.slice(-80);
                    });
                    loading = false;
                    render();
                }, 300);

                render();
            }

            function render() {
                return h('div', { class: 'flex flex-col gap-4 max-w-2xl' },
                    h('header', { class: 'flex items-center gap-3' },
                        createIcon('brain', 28),
                        h('h1', { class: 'h1' }, 'AI アシスト（ローカル版）')
                    ),

                    h('p', { class: 'text-muted' }, '外部APIに依存せず、ブラウザ内で動作するAI支援ツールです。'),

                    // Chat History
                    h('section', {
                        class: 'card',
                        style: { maxHeight: '400px', overflowY: 'auto' }
                    },
                        h('div', { class: 'card-body flex flex-col gap-4' },
                            ai.history.length === 0 ?
                                h('p', { class: 'text-muted text-center py-8' },
                                    '会話を始めましょう。タスク分解、設計支援、トラブルシューティングなどが可能です。'
                                ) :
                                ai.history.flatMap(h => [
                                    h('div', { class: 'flex flex-col gap-1' },
                                        h('div', {
                                            class: 'self-end p-3 rounded-lg',
                                            style: { background: 'rgba(var(--color-primary-rgb),0.1)', maxWidth: '80%' }
                                        }, h.prompt),
                                        h('div', {
                                            class: 'self-start p-3 rounded-lg',
                                            style: { background: 'var(--bg-tertiary)', maxWidth: '80%', whiteSpace: 'pre-wrap' }
                                        }, h.response),
                                        h('span', { class: 'text-xs text-muted self-start' },
                                            new Date(h.timestamp).toLocaleTimeString()
                                        )
                                    )
                                ])
                        )
                    ),

                    // Input
                    h('section', { class: 'card' },
                        h('div', { class: 'card-body' },
                            h('div', { class: 'flex gap-3' },
                                h('input', {
                                    class: 'input',
                                    placeholder: '例：デプロイ手順を分解して、タスク管理アプリの説明文を書いて...',
                                    disabled: loading,
                                    onkeydown: (e) => {
                                        if (e.key === 'Enter') {
                                            submit(e.target.value);
                                            e.target.value = '';
                                        }
                                    }
                                }),
                                h('button', {
                                    class: 'btn btn-primary',
                                    disabled: loading,
                                    onclick: (e) => {
                                        const input = e.target.previousElementSibling;
                                        submit(input.value);
                                        input.value = '';
                                    }
                                }, loading ? '生成中...' : '送信')
                            )
                        )
                    )
                );
            }

            return render();
        }

        // ===== Component: Settings Page =====
        function SettingsPage() {
            const state = State.get();

            let importMode = 'append'; // append | upsert | strict
            let includeProfile = true;
            let includeProjects = true;
            let includeApps = true;

            // ---- Projects management (v2 superset; information-lossless) ----
            const defaultProjectIds = new Set((Store.createDefaultStore().projects || []).map(p => p.id));
            let newName = '';
            let newCategory = '';
            let newSummary = '';
            let newProblem = '';
            let newApproach = '';
            let newTags = '';
            let newTech = '';
            let newDemo = '';

            function normalizeAndCommit(mutator) {
                State.update(d => {
                    mutator(d);
                    const normalized = Store.validateAndNormalize(d);
                    Object.keys(d).forEach(k => delete d[k]);
                    Object.assign(d, normalized);
                });
            }

            function toggleHiddenProject(id) {
                normalizeAndCommit(d => {
                    d.projectPrefs = d.projectPrefs || { hiddenIds: [] };
                    const set = new Set((d.projectPrefs.hiddenIds || []).map(String));
                    const key = String(id);
                    if (set.has(key)) set.delete(key);
                    else set.add(key);
                    d.projectPrefs.hiddenIds = Array.from(set).slice(0, 1000);
                });
                Toast.show('更新しました', 'success');
                render();
            }

            function deleteProjectHard(id) {
                if (!confirm('このプロジェクトを削除しますか？（ユーザー追加分のみ推奨）')) return;
                normalizeAndCommit(d => {
                    d.projects = (d.projects || []).filter(p => p && String(p.id) !== String(id));
                    if (d.projectPrefs && Array.isArray(d.projectPrefs.hiddenIds)) {
                        d.projectPrefs.hiddenIds = d.projectPrefs.hiddenIds.filter(x => String(x) !== String(id));
                    }
                });
                Toast.show('削除しました', 'success');
                render();
            }

            function addProjectManual() {
                const name = String(newName || '').trim();
                if (!name) { Toast.show('Project name は必須です', 'error'); return; }

                normalizeAndCommit(d => {
                    const existingSlugs = new Set((d.projects || []).map(p => p && p.slug).filter(Boolean));
                    let slug = slugify(name);
                    if (existingSlugs.has(slug)) slug = `${slug}-${uid().slice(0, 4)}`;
                    const id = `u${uid().slice(0, 10)}`;

                    const raw = {
                        id,
                        slug,
                        name,
                        category: String(newCategory || 'Misc').trim() || 'Misc',
                        summary: String(newSummary || '').trim(),
                        problem: String(newProblem || '').trim(),
                        approach: String(newApproach || '').trim(),
                        tags: String(newTags || '').split(',').map(s => s.trim()).filter(Boolean).slice(0, 30),
                        tech: String(newTech || '').split(',').map(s => s.trim()).filter(Boolean).slice(0, 30),
                        demoRoute: ['task', 'todo', 'pomodoro', 'ai'].includes(String(newDemo)) ? String(newDemo) : null,
                    };

                    d.projects = (d.projects || []).concat([raw]);
                });

                newName = ''; newCategory = ''; newSummary = ''; newProblem = ''; newApproach = ''; newTags = ''; newTech = ''; newDemo = '';
                Toast.show('追加しました', 'success');
                render();
            }


            function downloadJson(obj, filename) {
                const data = JSON.stringify(obj, null, 2);
                const blob = new Blob([data], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
            }

            function exportFull() {
                downloadJson(state, `portfolio-full-${new Date().toISOString().slice(0, 10)}.json`);
                Toast.show('フルバックアップをダウンロードしました', 'success');
            }

            function exportProjects() {
                downloadJson({ type: 'projects-only', schemaVersion: CONSTANTS.SCHEMA_VERSION, projects: state.projects }, `portfolio-projects-${new Date().toISOString().slice(0, 10)}.json`);
                Toast.show('Projectsをダウンロードしました', 'success');
            }

            function exportApps() {
                downloadJson({ type: 'apps-only', schemaVersion: CONSTANTS.SCHEMA_VERSION, appsData: state.appsData }, `portfolio-apps-${new Date().toISOString().slice(0, 10)}.json`);
                Toast.show('AppsDataをダウンロードしました', 'success');
            }

            function exportProfile() {
                downloadJson({ type: 'profile-only', schemaVersion: CONSTANTS.SCHEMA_VERSION, profile: state.profile }, `portfolio-profile-${new Date().toISOString().slice(0, 10)}.json`);
                Toast.show('Profileをダウンロードしました', 'success');
            }

            function setSnapshot() {
                try {
                    const payload = { at: Date.now(), store: State.get() };
                    localStorage.setItem(CONSTANTS.SNAPSHOT_KEY, JSON.stringify(payload));
                    Toast.show('スナップショットを保存しました', 'success');
                    render();
                } catch (e) {
                    Toast.show('スナップショット保存に失敗: ' + e.message, 'error');
                }
            }

            function getSnapshot() {
                try {
                    const raw = localStorage.getItem(CONSTANTS.SNAPSHOT_KEY);
                    if (!raw) return null;
                    const obj = JSON.parse(raw);
                    if (!obj || typeof obj !== 'object' || !obj.store) return null;
                    return obj;
                } catch {
                    return null;
                }
            }

            function restoreSnapshot() {
                const snap = getSnapshot();
                if (!snap) {
                    Toast.show('スナップショットがありません', 'error');
                    return;
                }
                if (!confirm('スナップショットへ復元しますか？現在のデータは上書きされます。')) return;
                try {
                    const normalized = Store.validateAndNormalize(snap.store);
                    State.set(normalized);
                    Toast.show('スナップショットへ復元しました', 'success');
                } catch (e) {
                    Toast.show('復元に失敗: ' + e.message, 'error');
                }
            }

            function clearSnapshot() {
                localStorage.removeItem(CONSTANTS.SNAPSHOT_KEY);
                Toast.show('スナップショットを削除しました', 'success');
                render();
            }

            function mergeProjects(current, incoming, mode) {
                const cur = (Array.isArray(current) ? current : []).map((p, i) => normalizeProject(p, i));
                const inc = (Array.isArray(incoming) ? incoming : []).map((p, i) => normalizeProject(p, i));
                if (mode === 'strict') return inc;

                const byId = new Map(cur.map(p => [p.id, p]));
                const bySlug = new Map(cur.map(p => [p.slug, p]));
                const out = cur.slice();

                for (const p of inc) {
                    const hit = byId.get(p.id) || bySlug.get(p.slug);
                    if (!hit) {
                        if (mode === 'append' || mode === 'upsert') {
                            out.push(p);
                            byId.set(p.id, p);
                            bySlug.set(p.slug, p);
                        }
                        continue;
                    }
                    if (mode === 'upsert') {
                        const merged = { ...hit, ...p, id: hit.id, slug: hit.slug };
                        const idx = out.findIndex(x => x.id === hit.id);
                        if (idx >= 0) out[idx] = merged;
                        byId.set(hit.id, merged);
                        bySlug.set(hit.slug, merged);
                    }
                }
                return out.slice(0, CONSTANTS.LIMITS.MAX_PROJECTS);
            }

            function mergeApps(current, incoming, mode) {
                const cur = normalizeAppsData(current || {});
                const inc = normalizeAppsData(incoming || {});
                if (mode === 'strict') return inc;

                // tasks/todos: append or upsert by id
                const mergeList = (curList, incList, upsert) => {
                    const out = Array.isArray(curList) ? curList.slice() : [];
                    const byId = new Map(out.map(x => [x.id, x]));
                    for (const x of (Array.isArray(incList) ? incList : [])) {
                        if (!x || !x.id) continue;
                        const hit = byId.get(x.id);
                        if (!hit) {
                            out.push(x);
                            byId.set(x.id, x);
                        } else if (upsert) {
                            const merged = { ...hit, ...x, id: hit.id };
                            const idx = out.findIndex(t => t.id === hit.id);
                            if (idx >= 0) out[idx] = merged;
                            byId.set(hit.id, merged);
                        }
                    }
                    return out;
                };

                const upsert = mode === 'upsert';
                const merged = normalizeAppsData({
                    tasks: mergeList(cur.tasks, inc.tasks, upsert),
                    todos: mergeList(cur.todos, inc.todos, upsert),
                    pomodoro: {
                        history: (cur.pomodoro.history || []).concat(inc.pomodoro.history || []).slice(-500),
                        settings: upsert ? { ...cur.pomodoro.settings, ...inc.pomodoro.settings } : cur.pomodoro.settings,
                        runtime: cur.pomodoro.runtime,
                    },
                    ai: {
                        history: (cur.ai.history || []).concat(inc.ai.history || []).slice(-500),
                    }
                });
                return merged;
            }

            function mergeProfile(current, incoming, mode) {
                const cur = (current && typeof current === 'object') ? current : {};
                const inc = (incoming && typeof incoming === 'object') ? incoming : {};
                if (mode === 'strict') return { ...inc };
                if (mode === 'upsert') return { ...cur, ...inc };
                return { ...cur }; // append does not touch profile by default (unless strict/upsert)
            }

            function importJSON(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);

                        State.update((draft) => {
                            // Full-store or partial formats supported
                            const isFull = data && data.type === 'full-store';
                            const incomingProfile = isFull ? data.profile : data.profile;
                            const incomingProjects = isFull ? data.projects : data.projects;
                            const incomingApps = isFull ? data.appsData : data.appsData;
                            const incomingPrefs = data && data.projectPrefs;

                            if (importMode === 'strict' && isFull) {
                                const normalized = Store.validateAndNormalize(data);
                                // validateAndNormalize expects full store shape; keep it safe
                                State.set(normalized);
                                return;
                            }

                            if (includeProfile && incomingProfile) {
                                draft.profile = mergeProfile(draft.profile, incomingProfile, importMode);
                            }
                            if (includeProjects && incomingProjects) {
                                draft.projects = mergeProjects(draft.projects, incomingProjects, importMode);
                                // ensure defaults are never lost
                                draft.projects = mergeProjectsWithDefaults(draft.projects);
                                if (incomingPrefs && typeof incomingPrefs === 'object') {
                                    draft.projectPrefs = {
                                        hiddenIds: Array.isArray(incomingPrefs.hiddenIds)
                                            ? incomingPrefs.hiddenIds.map(String).filter(Boolean).slice(0, 1000)
                                            : []
                                    };
                                }
                            }
                            if (includeApps && incomingApps) {
                                draft.appsData = mergeApps(draft.appsData, incomingApps, importMode);
                            }

                            // Final normalize pass for safety
                            const normalized = Store.validateAndNormalize(draft);
                            Object.assign(draft, normalized);
                        });

                        Toast.show('インポートしました', 'success');
                        render();
                    } catch (err) {
                        Toast.show('インポートに失敗しました: ' + err.message, 'error');
                    }
                };
                reader.readAsText(file);
            }

            function resetData() {
                if (!confirm('すべてのデータを初期状態に戻しますか？この操作は取り消せません。')) return;
                State.set(Store.createDefaultStore());
                Theme.apply('system');
                Toast.show('初期化しました', 'success');
                render();
            }

            function normalizeNow() {
                try {
                    const before = State.get();
                    const beforeCounts = { p: before.projects.length, t: before.appsData.tasks.length, td: before.appsData.todos.length };
                    const normalized = Store.validateAndNormalize(before);
                    const afterCounts = { p: normalized.projects.length, t: normalized.appsData.tasks.length, td: normalized.appsData.todos.length };
                    State.set(normalized);
                    Toast.show(`整合性チェック/正規化完了 (P:${beforeCounts.p}→${afterCounts.p}, T:${beforeCounts.t}→${afterCounts.t}, TODO:${beforeCounts.td}→${afterCounts.td})`, 'success');
                    render();
                } catch (e) {
                    Toast.show('整合性チェックに失敗: ' + e.message, 'error');
                }
            }

            function moveProject(idx, dir) {
                State.update(draft => {
                    const arr = draft.projects;
                    const j = idx + dir;
                    if (!arr || idx < 0 || j < 0 || idx >= arr.length || j >= arr.length) return;
                    const tmp = arr[idx];
                    arr[idx] = arr[j];
                    arr[j] = tmp;
                });
                render();
            }

            function render() {
                const snap = getSnapshot();
                return h('div', { class: 'flex flex-col gap-6' },
                    h('header', {},
                        h('h1', { class: 'h1' }, '設定・データ'),
                        h('p', { class: 'text-muted' }, 'Import/Export、スナップショット、整合性チェック、並び替え。')
                    ),

                    h('section', { class: 'card' },
                        h('div', { class: 'card-body flex flex-col gap-3' },
                            h('h2', { class: 'h3' }, 'エクスポート'),
                            h('div', { class: 'flex flex-wrap gap-2' },
                                h('button', { class: 'btn btn-primary', onclick: exportFull }, 'フルバックアップ'),
                                h('button', { class: 'btn btn-secondary', onclick: exportProjects }, 'Projectsのみ'),
                                h('button', { class: 'btn btn-secondary', onclick: exportApps }, 'AppsDataのみ'),
                                h('button', { class: 'btn btn-secondary', onclick: exportProfile }, 'Profileのみ')
                            ),
                            h('p', { class: 'text-muted text-sm' }, 'フルバックアップは v2/v7 系の互換を考慮した形式です。')
                        )
                    ),

                    h('section', { class: 'card' },
                        h('div', { class: 'card-body flex flex-col gap-3' },
                            h('h2', { class: 'h3' }, 'インポート（欠損ゼロ）'),
                            h('div', { class: 'grid grid-cols-2 gap-3' },
                                h('div', {},
                                    h('label', { class: 'text-sm text-muted' }, 'モード'),
                                    h('select', { class: 'input', onchange: (e) => { importMode = e.target.value; }, value: importMode },
                                        h('option', { value: 'append' }, 'append（追加のみ）'),
                                        h('option', { value: 'upsert' }, 'upsert（更新+追加）'),
                                        h('option', { value: 'strict' }, 'strict（全置換）')
                                    )
                                ),
                                h('div', {},
                                    h('label', { class: 'text-sm text-muted' }, '対象'),
                                    h('div', { class: 'flex flex-wrap gap-2' },
                                        h('label', { class: 'btn btn-ghost btn-sm' },
                                            h('input', { type: 'checkbox', checked: includeProfile, onchange: (e) => { includeProfile = !!e.target.checked; } }),
                                            h('span', { style: { marginLeft: '8px' } }, 'Profile')
                                        ),
                                        h('label', { class: 'btn btn-ghost btn-sm' },
                                            h('input', { type: 'checkbox', checked: includeProjects, onchange: (e) => { includeProjects = !!e.target.checked; } }),
                                            h('span', { style: { marginLeft: '8px' } }, 'Projects')
                                        ),
                                        h('label', { class: 'btn btn-ghost btn-sm' },
                                            h('input', { type: 'checkbox', checked: includeApps, onchange: (e) => { includeApps = !!e.target.checked; } }),
                                            h('span', { style: { marginLeft: '8px' } }, 'AppsData')
                                        ),
                                    )
                                )
                            ),
                            h('div', {},
                                h('input', {
                                    type: 'file',
                                    class: 'input',
                                    accept: 'application/json',
                                    onchange: (e) => {
                                        const f = e.target.files && e.target.files[0];
                                        if (f) importJSON(f);
                                        e.target.value = '';
                                    }
                                })
                            ),
                            h('p', { class: 'text-muted text-sm' }, 'Projectsは常に「v2のデフォルト18件」を維持しつつ、あなたの編集を優先してマージします。')
                        )
                    ),

                    h('section', { class: 'card' },
                        h('div', { class: 'card-body flex flex-col gap-3' },
                            h('h2', { class: 'h3' }, 'スナップショット'),
                            h('div', { class: 'flex flex-wrap gap-2' },
                                h('button', { class: 'btn btn-secondary', onclick: setSnapshot }, '保存'),
                                h('button', { class: 'btn btn-secondary', onclick: restoreSnapshot, disabled: !snap }, '復元'),
                                h('button', { class: 'btn btn-ghost', onclick: clearSnapshot, disabled: !snap }, '削除')
                            ),
                            snap
                                ? h('p', { class: 'text-muted text-sm' }, `保存日時: ${new Date(snap.at).toLocaleString()}`)
                                : h('p', { class: 'text-muted text-sm' }, 'スナップショットは未保存です。')
                        )
                    ),

                    h('section', { class: 'card' },
                        h('div', { class: 'card-body flex flex-col gap-3' },
                            h('h2', { class: 'h3' }, '並び替え（Projects）'),
                            h('div', { class: 'text-muted text-sm' }, '上下ボタンで表示順を調整できます。'),
                            h('div', { class: 'flex flex-col gap-2', style: { maxHeight: '360px', overflow: 'auto', paddingRight: '4px' } },
                                ...state.projects.map((p, idx) =>
                                    h('div', { class: 'flex items-center justify-between gap-2' },
                                        h('div', { class: 'flex items-center gap-2' },
                                            h('span', { class: 'badge badge-gray' }, String(idx + 1)),
                                            h('span', { class: 'text-sm' }, p.name)
                                        ),
                                        h('div', { class: 'flex items-center gap-2' },
                                            h('button', { class: 'btn btn-ghost btn-sm', onclick: () => moveProject(idx, -1), disabled: idx === 0 }, '↑'),
                                            h('button', { class: 'btn btn-ghost btn-sm', onclick: () => moveProject(idx, +1), disabled: idx === state.projects.length - 1 }, '↓')
                                        )
                                    )
                                )
                            )
                        )
                    ),



                    h('section', { class: 'card' },
                        h('div', { class: 'card-body flex flex-col gap-3' },
                            h('h2', { class: 'h3' }, 'Projects管理（追加 / 非表示 / 削除）'),
                            h('p', { class: 'text-muted text-sm' }, 'デフォルト（v2の18件）は「非表示」で扱い、ユーザー追加分は「削除」も可能です（情報欠損0）。'),
                            h('div', { class: 'grid grid-cols-2 gap-3' },
                                h('div', {},
                                    h('label', { class: 'text-sm text-muted' }, 'Project name（必須）'),
                                    h('input', { class: 'input', placeholder: '例: 新規プロジェクト', oninput: (e) => { newName = e.target.value; } })
                                ),
                                h('div', {},
                                    h('label', { class: 'text-sm text-muted' }, 'Category'),
                                    h('input', { class: 'input', placeholder: '例: Productivity / AI', oninput: (e) => { newCategory = e.target.value; } })
                                ),
                                h('div', { class: 'col-span-2' },
                                    h('label', { class: 'text-sm text-muted' }, 'Summary'),
                                    h('textarea', { class: 'input', placeholder: '短い説明', style: 'min-height:84px;', oninput: (e) => { newSummary = e.target.value; } })
                                ),
                                h('div', { class: 'col-span-2' },
                                    h('label', { class: 'text-sm text-muted' }, 'Problem / Risk'),
                                    h('textarea', { class: 'input', placeholder: '課題・リスク（任意）', style: 'min-height:84px;', oninput: (e) => { newProblem = e.target.value; } })
                                ),
                                h('div', { class: 'col-span-2' },
                                    h('label', { class: 'text-sm text-muted' }, 'Approach / Solution'),
                                    h('textarea', { class: 'input', placeholder: '方針・解決策（任意）', style: 'min-height:84px;', oninput: (e) => { newApproach = e.target.value; } })
                                ),
                                h('div', {},
                                    h('label', { class: 'text-sm text-muted' }, 'Tags（カンマ区切り）'),
                                    h('input', { class: 'input', placeholder: '例: #ツール,#効率化', oninput: (e) => { newTags = e.target.value; } })
                                ),
                                h('div', {},
                                    h('label', { class: 'text-sm text-muted' }, 'Tech（カンマ区切り）'),
                                    h('input', { class: 'input', placeholder: '例: JS,HTML,CSS', oninput: (e) => { newTech = e.target.value; } })
                                ),
                                h('div', {},
                                    h('label', { class: 'text-sm text-muted' }, 'Demo（任意）'),
                                    h('select', { class: 'input', onchange: (e) => { newDemo = e.target.value; } },
                                        h('option', { value: '' }, 'Demoなし'),
                                        h('option', { value: 'task' }, 'task'),
                                        h('option', { value: 'todo' }, 'todo'),
                                        h('option', { value: 'pomodoro' }, 'pomodoro'),
                                        h('option', { value: 'ai' }, 'ai')
                                    )
                                ),
                                h('div', { class: 'flex items-end' },
                                    h('button', { class: 'btn btn-primary w-full', onclick: addProjectManual }, '追加')
                                )
                            ),
                            (() => {
                                const hidden = new Set(((state.projectPrefs && state.projectPrefs.hiddenIds) || []).map(String));
                                const visibleCount = state.projects.filter(p => !hidden.has(String(p.id))).length;
                                const hiddenCount = state.projects.length - visibleCount;
                                return h('div', { class: 'text-muted text-sm' }, `表示: ${visibleCount} / 非表示: ${hiddenCount} / 総数: ${state.projects.length}`);
                            })(),
                            h('div', { class: 'flex flex-col gap-2', style: { maxHeight: '420px', overflow: 'auto', paddingRight: '4px' } },
                                ...state.projects.map(p => {
                                    const hidden = new Set(((state.projectPrefs && state.projectPrefs.hiddenIds) || []).map(String));
                                    const isHidden = hidden.has(String(p.id));
                                    const isDefault = defaultProjectIds.has(String(p.id));
                                    return h('div', { class: 'flex items-center justify-between gap-2' },
                                        h('div', { class: 'flex items-center gap-2' },
                                            h('span', { class: 'badge badge-gray' }, isDefault ? 'default' : 'user'),
                                            h('span', { class: 'text-sm' }, p.name),
                                            isHidden ? h('span', { class: 'badge badge-green' }, 'hidden') : null
                                        ),
                                        h('div', { class: 'flex items-center gap-2' },
                                            h('button', { class: 'btn btn-ghost btn-sm', onclick: () => toggleHiddenProject(p.id) }, isHidden ? '表示' : '非表示'),
                                            h('button', { class: 'btn btn-danger btn-sm', disabled: isDefault, title: isDefault ? 'デフォルトは非表示のみ（情報欠損0）' : '', onclick: () => deleteProjectHard(p.id) }, '削除')
                                        )
                                    );
                                })
                            )
                        )
                    ),
                    h('section', { class: 'card' },
                        h('div', { class: 'card-body flex flex-col gap-3' },
                            h('h2', { class: 'h3' }, '整合性チェック / 正規化'),
                            h('div', { class: 'flex flex-wrap gap-2' },
                                h('button', { class: 'btn btn-secondary', onclick: normalizeNow }, '実行'),
                                h('button', { class: 'btn btn-danger', onclick: resetData }, '全リセット')
                            ),
                            h('p', { class: 'text-muted text-sm' }, '正規化はデータ破損・型揺れ・上限超過などを安全側に丸めます。')
                        )
                    )
                );
            }

            return render();
        }

        // ===== Component: Static Pages =====
        function AboutPage() {
            const profile = State.get().profile;
            return h('article', { class: 'flex flex-col gap-6 max-w-2xl' },
                h('header', {}, h('h1', { class: 'h1' }, 'About')),
                h('section', { class: 'card' },
                    h('div', { class: 'card-body' },
                        h('h2', { class: 'h3' }, profile.name),
                        h('p', { class: 'text-muted mb-4' }, profile.title),
                        h('p', { class: 'text-muted', style: { whiteSpace: 'pre-wrap', lineHeight: '1.8' } }, profile.bio)
                    )
                )
            );
        }

        function ResumePage() {
            return h('article', { class: 'flex flex-col gap-6 max-w-2xl' },
                h('header', {}, h('h1', { class: 'h1' }, 'Resume')),
                h('section', { class: 'card' },
                    h('div', { class: 'card-body' },
                        h('h3', { class: 'h3 mb-4' }, State.get().profile.title),
                        h('ul', { class: 'text-muted', style: { lineHeight: '2', paddingLeft: '1.5rem' } },
                            h('li', {}, 'ProjectsをCase Study形式で整理'),
                            h('li', {}, '内蔵Apps（Task/Todo/Pomodoro/AI）を作品として掲載'),
                            h('li', {}, '整合性チェック/自動修復＋スナップショットで運用事故率を低減'),
                            h('li', {}, 'セマンティックHTML5 + ARIA対応'),
                            h('li', {}, '単一HTMLで完結（依存性最小化）')
                        )
                    )
                )
            );
        }

        function ContactPage() {
            const profile = State.get().profile;
            return h('article', { class: 'flex flex-col gap-6 max-w-2xl' },
                h('header', {}, h('h1', { class: 'h1' }, 'Contact')),
                h('section', { class: 'card' },
                    h('div', { class: 'card-body' },
                        h('div', { class: 'flex flex-col gap-4' },
                            h('div', { class: 'flex justify-between py-2 border-bottom', style: { borderColor: 'var(--border-color)' } },
                                h('span', { class: 'text-muted' }, 'Email'),
                                h('a', { href: `mailto:${profile.email}`, class: 'font-mono' }, profile.email)
                            ),
                            profile.github ? h('div', { class: 'flex justify-between py-2 border-bottom', style: { borderColor: 'var(--border-color)' } },
                                h('span', { class: 'text-muted' }, 'GitHub'),
                                h('a', { href: profile.github, target: '_blank', rel: 'noopener' }, profile.github)
                            ) : null,
                            profile.linkedin ? h('div', { class: 'flex justify-between py-2' },
                                h('span', { class: 'text-muted' }, 'LinkedIn'),
                                h('a', { href: profile.linkedin, target: '_blank', rel: 'noopener' }, profile.linkedin)
                            ) : null,
                            h('button', {
                                class: 'btn btn-primary mt-4',
                                onclick: () => location.href = `mailto:${profile.email}`
                            }, h('span', {}, createIcon('mail', 18), ' メールを作成'))
                        )
                    )
                )
            );
        }

        const quizData = {
            "1. コンピュート & インスタンス (EC2, EBS)": [
                {
                    "section": "1. コンピュート & インスタンス (EC2, EBS)",
                    "id": "Q1",
                    "title": "Q1. ステータスチェックの厳密な切り分け",
                    "content": [
                        "状況: EC2が応答しない。「システムステータスチェック」が失敗している。",
                        "問: 再起動（Reboot）ではなく「停止・開始（Stop/Start）」を選択すべき技術的理由は何か？この操作によってAWS内部で何が行われるか？"
                    ]
                },
                {
                    "section": "1. コンピュート & インスタンス (EC2, EBS) - 上級編",
                    "id": "Q1",
                    "title": "Q1. インスタンス障害の厳密な切り分けとリカバリ・自動化戦略",
                    "content": [
                        "本番稼働中のEC2インスタンス（Linux）へのSSH接続がタイムアウトし、サービス応答も途絶えた。CloudWatchを確認すると「システムステータスチェック（System Status Check）」が失敗している。一方で「インスタンスステータスチェック」は成功しているように見える。このインスタンスはASG（Auto Scaling Group）管理下にあるが、なぜか自動復旧していない。",
                        "Challenge",
                        "「システムステータスチェック」と「インスタンスステータスチェック」の失敗が示す物理的・論理的な責任境界を、ハイパーバイザーとOSのレイヤーから厳密に定義せよ。",
                        "この状況で、オペレーターが手動で Reboot を実行しても問題が解決しない可能性が高い技術的理由と、Stop/Start が物理ホストレベルで何を引き起こすか（Migrationメカニズム）を解説せよ。",
                        "ASGのヘルスチェックタイプが「EC2」であるにもかかわらず、システムステータスチェック失敗時に即座に置換されないケースがある。ASGがEC2の不調を検知してインスタンスを置換するための正確な条件と、「EC2 Auto Recovery」との機能的な違いを述べよ。",
                        "Core Knowledge & Tech Lead's View:",
                        "境界点:",
                        "システムステータスチェック: AWS側の責任範囲。物理ホストの電源、ネットワーク接続、物理ディスク、またはハイパーバイザー（Nitro System等）自体の障害を示す。ユーザーの操作では修復不可能。",
                        "インスタンスステータスチェック: ユーザー側の責任範囲。ゲストOSのカーネルパニック、ファイルシステム破損、ネットワーク設定ミス（iptables/NIC設定）、メモリ枯渇によるプロセスハングなどが原因。",
                        "Reboot vs Stop/Start:",
                        "Reboot は同一物理ホスト上でのOS再起動に過ぎないため、物理ホスト自体（システムステータス）に障害がある場合は復旧しない。",
                        "Stop はインスタンスと物理ホストの紐付けを解除し、Start は健全な別の物理ホストへインスタンスを新規配置（Migration）する操作であるため、物理障害からの確実な回避策となる。",
                        "注意: インスタンスストア（Ephemeral Storage）のデータはStopにより完全に消失する。",
                        "ASG vs Auto Recovery:",
                        "ASGの「EC2」ヘルスチェックは、ステータスチェック失敗を検知してインスタンスをTerminate & Replace（削除して新規作成）する。ステートフルなデータは消える。",
                        "EC2 Auto Recoveryは、インスタンスをTerminateせず、同じインスタンスID、同じEBSボリューム、同じEIPを保持したままStop/Start相当の復旧（物理ホスト移動）を自動で行う。",
                        "現場の視点: 単なるWebサーバーならASGの置換で良いが、固定IPや特定EBSが必要な管理サーバー等はEC2 Auto Recoveryを設定すべき。"
                    ]
                },
                {
                    "section": "1. コンピュート & インスタンス (EC2, EBS)",
                    "id": "Q2",
                    "title": "Q2. インスタンスステータスチェック失敗時のレスキュー",
                    "content": [
                        "状況: 「インスタンスステータスチェック」が失敗し、SSHも繋がらない。重要データがありTerminateできない。",
                        "問: ログ調査とファイルシステム修復のために行う「レスキューインスタンス」の手順とは？"
                    ]
                },
                {
                    "section": "1. コンピュート & インスタンス (EC2, EBS) - 上級編",
                    "id": "Q2",
                    "title": "Q2. EBS (gp2/gp3/io2) のパフォーマンス仕様とスループットの罠",
                    "content": [
                        "レガシーなDBサーバーで gp2 ボリューム（500GB）を使用している。IOPS上限（1,500 IOPS）には達していないが、バッチ処理中にディスクレイテンシが悪化し、CloudWatchの BurstBalance が0%に張り付いている。コスト削減と性能安定のため gp3 への移行を計画したが、移行後にIOPSは足りているはずなのに、逆に処理時間が2倍に延びる障害が発生した。",
                        "Challenge:",
                        "gp2 における「クレジットバケツモデル」の計算式（ベースラインIOPSと蓄積レート）に基づき、500GBボリュームがバースト枯渇を起こすメカニズムを数値で証明せよ。",
                        "gp3 移行時に多くのエンジニアが見落とす「スループット（MiB/s）」のデフォルト制限値と、それがDBのシーケンシャルリード/ライトに与える影響を説明せよ。",
                        "ミッションクリティカルなDBにおいて、gp3 ではなくあえて io2 Block Express を選択すべき技術的条件（レイテンシ、耐久性、マルチアタッチ）を挙げよ。",
                        "Core Knowledge & Tech Lead's View:",
                        "gp2の枯渇:",
                        "ベースラインは 3 IOPS/GB。500GBの場合、500 * 3 = 1,500 IOPS がベースライン。",
                        "3,000 IOPSまでバースト可能だが、ベースラインを超過中はクレジットを消費する。クレジットが枯渇すると、強制的に1,500 IOPSに制限（スロットリング）される。",
                        "gp3の罠 (Throughput):",
                        "gp3 はベースライン3,000 IOPSを保証するが、スループットのデフォルトは 125 MiB/s である。",
                        "一方、gp2 (500GB) のスループット上限はバースト時 250 MiB/s まで出る仕様になっている（容量依存）。",
                        "失敗原因: 移行時にスループット設定をデフォルト（125 MiB/s）のままにしたため、帯域幅が半分になり、大量のデータを読み書きするバッチ処理が遅延した。gp3では明示的にスループットを追加購入する必要がある。",
                        "io2 Block Expressの出番:",
                        "サブミリ秒の低レイテンシが必要な場合。",
                        "99.999% (ファイブナイン) の耐久性が必要な場合（gp3は99.8-99.9%）。",
                        "Multi-Attach（複数のEC2から同時に書き込み可能なクラスタ構成）が必要な場合。"
                    ]
                },
                {
                    "section": "1. コンピュート & インスタンス (EC2, EBS)",
                    "id": "Q3",
                    "title": "Q3. インスタンスストアの揮発性",
                    "content": [
                        "状況: インスタンスストア（Ephemeral Storage）を持つインスタンスタイプ（i3など）をStop/Startした。",
                        "問: インスタンスストア内のデータはどうなるか？また、Rebootの場合はどうなるか？",
                        "リソースとパフォーマンス"
                    ]
                },
                {
                    "section": "1. コンピュート & インスタンス (EC2, EBS) - 上級編",
                    "id": "Q3",
                    "title": "Q3. インスタンス起動時のデバッグとUser Data",
                    "content": [
                        "Auto Scaling Groupで起動したインスタンスが、アプリの起動スクリプト（User Data）のエラーにより Unhealthy と判定され、ログを確認する前にTerminateされてしまう現象がループしている。User DataはBase64エンコードされており、手動デコードしても構文エラーは見当たらない。",
                        "Challenge:",
                        "起動失敗したインスタンスをTerminateさせずに一時停止（Pending:Wait / Terminating:Wait）させ、デバッグを行うためのASG機能とその具体的な設定フック名を答えよ。",
                        "Linuxにおける cloud-init の実行フェーズ（init、 config、 final）において、User Data（シェルスクリプト）はどの段階で実行されるか？ また、標準出力・エラー出力が記録される完全なログパスを示せ。",
                        "User Dataが正しく記述されているにもかかわらず、スクリプトが途中終了したり実行されない場合によくある、「改行コード」や「シェバン（#!）」にまつわるトラブル原因を挙げよ。",
                        "Core Knowledge & Tech Lead's View:",
                        "Lifecycle Hooks:",
                        "ASGの Lifecycle Hook を設定する。",
                        "起動時デバッグなら autoscaling:EC2_INSTANCE_LAUNCHING フックで、遷移を Pending:Wait 状態で止める。これによりSSH/SSMでログインして調査が可能になる。",
                        "cloud-initの動作:",
                        "User Data（シェルスクリプト）は通常 final フェーズ（起動処理の最後）で実行される。",
                        "ログファイル: /var/log/cloud-init-output.log（スクリプトの標準出力/エラー出力はここ）。構造化ログは /var/log/cloud-init.log。",
                        "現場の罠:",
                        "Windowsで作成したファイルの改行コードが CRLF になっていると、Linuxのbashが解釈できずエラーになる（LF必須）。",
                        "#!/bin/bash のシェバンがないと、cloud-initがスクリプトとして認識しない場合がある。",
                        "Tech Lead's Tip: 本番でASGを止めるより、同じAMIとUser Dataを使って手動で単発インスタンスを起動し、再現確認するほうが安全かつ迅速な場合が多い。"
                    ]
                },
                {
                    "section": "1. コンピュート & インスタンス (EC2, EBS)",
                    "id": "Q4",
                    "title": "Q4. T系インスタンスとCPUクレジット",
                    "content": [
                        "状況: T3インスタンスのCPU使用率が20%で張り付き、極端に遅い。",
                        "問: 確認すべきメトリクスはCPUCreditBalanceだが、これを即座に解決するために有効にするモードは？また、そのコストへの影響は？"
                    ]
                },
                {
                    "section": "1. コンピュート & インスタンス (EC2, EBS)",
                    "id": "Q5",
                    "title": "Q5. EBSの初期化（ハイドレーション）",
                    "content": [
                        "状況: S3のスナップショットから復元した大容量EBSボリュームが、使用開始直後に激しいレイテンシを示す。",
                        "問: S3からの遅延読み込み（Lazy Loading）によるパフォーマンス低下を防ぐために、使用前に実行すべき操作は？"
                    ]
                },
                {
                    "section": "1. コンピュート & インスタンス (EC2, EBS)",
                    "id": "Q6",
                    "title": "Q6. EBSバーストバランス枯渇",
                    "content": [
                        "状況: gp2ボリュームでIOPS制限には達していないが、I/O待ちが増加している。",
                        "問: gp2特有のBurstBalanceメトリクスとは何か？これが枯渇した時の挙動と、gp3への移行メリットは？"
                    ]
                },
                {
                    "section": "1. コンピュート & インスタンス (EC2, EBS)",
                    "id": "Q7",
                    "title": "Q7. OSレベルの制限（No space left on device）",
                    "content": [
                        "状況: ディスク容量不足のエラーが出るが、df -hで見ると容量は余っている。",
                        "問: 容量（ブロック）以外に枯渇している可能性があるファイルシステムのリソースは？確認コマンドは？",
                        "焦点: パケットの消失、非対称ルーティング、DNSの挙動。",
                        "接続性とファイアウォール"
                    ]
                }
            ],
            "2. ネットワーキング(VPC, ELB, DX, DNS)": [
                {
                    "section": "2. ネットワーキング(VPC, ELB, DX, DNS) - 上級編",
                    "id": "Q4",
                    "title": "Q4. Security Group vs NACL: ステート管理と戻り通信の落とし穴",
                    "content": [
                        "特定の攻撃的なIPアドレス群からのアクセスをVPCレベルで遮断するため、ネットワークACL（NACL）でInbound DENYルールを設定した。しかし、設定直後から、そのサブネット内のサーバーが外部のリポジトリ（yum/apt）に接続できなくなり、サーバー監視のエージェントもタイムアウトし始めた。SG（セキュリティグループ）の設定は変更していない。",
                        "Challenge:",
                        "SGが「ステートフル」、NACLが「ステートレス」であることを踏まえ、NACLでのInbound遮断が、なぜ無関係なOutbound通信（外部へのリクエスト）の応答パケットに影響を与えるのか、エフェメラルポート（Ephemeral Ports）の挙動を用いて解説せよ。",
                        "サーバーから外部へ通信する場合、NACLのInbound/Outboundルールに最低限どのような許可設定が必要か？ TCPハンドシェイクの往復（SYN -> SYN/ACK -> ACK）に基づいて説明せよ。",
                        "Kubernetes (EKS) 環境において、Pod単位でSGを割り当てる機能（Security Groups for Pods）を使用する場合、ノードレベルのNACL設定との競合や制約について考慮すべき点は何か。",
                        "Core Knowledge & Tech Lead's View:",
                        "戻り通信の死:",
                        "NACLはステートレスなので、「行き」を許可しても「帰り」は自動許可されない。",
                        "サーバーが外部（yumリポジトリ等）へリクエストを送る際、送信元ポートとして エフェメラルポート（1024-65535等） を使用する。",
                        "外部からの応答（SYN/ACK）は、このエフェメラルポート宛てに戻ってくる。",
                        "もしNACLのInboundルールで、特定の攻撃IPを拒否するルールを追加した際、誤ってデフォルトの「Allow ALL」より優先順位が高い位置で広い範囲を拒否していたり、あるいは戻りのエフェメラルポート範囲を明示的に許可していなければ、正規の戻りパケットがドロップされる。",
                        "TCPハンドシェイク:",
                        "Outbound: Server -> External (Dst: 443, Src: 32768) [SYN] -> NACL Outbound許可が必要",
                        "Inbound: External -> Server (Dst: 32768, Src: 443) [SYN/ACK] -> NACL Inboundでポート1024-65535の許可が必要",
                        "EKSのSG:",
                        "Security Groups for Podsを使っても、通信は依然としてサブネットのNACLを通過する。NACLが厳しすぎるとPod通信も阻害される。",
                        "Tech Lead's View: NACLは「特定の攻撃IPを緊急ブロックする」等の用途に限定し、基本はAllow ALLで運用すべき。複雑なNACLはデバッグ不可能な障害を生む。"
                    ]
                },
                {
                    "section": "2. ネットワーキング(VPC, ELB, DX, DNS) - 上級編",
                    "id": "Q5",
                    "title": "Q5. DNS at Scale: VPC Resolverの制限とハイブリッドDNS",
                    "content": [
                        "マイクロサービスアーキテクチャを採用し、サービス間通信にDNSベースのサービスディスカバリを使用している。負荷テストを実施したところ、間欠的に名前解決エラー（NameResolutionError）が発生し始めた。また、オンプレミスとDirect Connectで接続された環境で、オンプレ側のDNSサーバーにあるドメインがVPCから引けない問題も発生している。",
                        "Challenge:",
                        "VPC内部DNSリゾルバ（169.254.169.253）に存在する ハードリミット（PPS制限） の具体的な数値と、それがネットワークインターフェース（ENI）単位であることを踏まえた対策（NodeLocal DNSCacheなど）を述べよ。",
                        "Route 53 Resolverの Outbound Endpoint と Forwarding Rule を用いて、VPCからオンプレミスのDNSを解決するアーキテクチャを説明せよ。逆に、オンプレからVPC内のPrivate Hosted Zoneを解決するには何が必要か？",
                        "DNSラウンドロビンによるロードバランシングの限界（クライアントサイドのキャッシュ挙動やスティッキー性）と、それを解決するための最新のサービスディスカバリ手法（AWS Cloud Map、 Envoy等）について論ぜよ。",
                        "Core Knowledge & Tech Lead's View:",
                        "PPS制限:",
                        "VPC DNSへのクエリは 1024 パケット/秒 (PPS) / ENI というハードリミットがある。",
                        "マイクロサービスで短命な接続を大量に繰り返すとこれに抵触する。",
                        "対策: Kubernetesなら NodeLocal DNSCache を導入し、各ノード上でDNSキャッシュを行うことでVPCリゾルバへの問い合わせを減らす。アプリ側でもDNS TTLを適切に扱う。",
                        "ハイブリッドDNS:",
                        "VPC -> On-Prem: Route 53 Resolver Outbound Endpoint を作成し、転送ルール（Forwarding Rule）で「example.corp」等のクエリをオンプレDNSサーバーIPへ転送する。",
                        "On-Prem -> VPC: Route 53 Resolver Inbound Endpoint を作成し、オンプレDNS側で条件付きフォワーダー（Conditional Forwarder）を設定して、VPC内のドメインクエリをInbound EndpointのIPへ飛ばす。",
                        "DNSラウンドロビンの限界:",
                        "Java等のクライアントはDNS解決結果を永続的にキャッシュする傾向があり（TTL無視）、特定のIPに負荷が偏る。",
                        "モダンな対策: Service Mesh (Envoy/App Mesh) や AWS Cloud Map を使い、DNSに依存しないAPIベースのディスカバリや、クライアントサイドロードバランシングを行う。"
                    ]
                },
                {
                    "section": "2. ネットワーキング(VPC, ELB, DX, DNS) - 上級編",
                    "id": "Q6",
                    "title": "Q6. Transit Gateway (TGW) の非対称ルーティングとAppliance Mode",
                    "content": [
                        "TGWを中心としたハブ＆スポーク構成で、セキュリティVPC（Inspection VPC）にファイアウォールアプライアンスを配置し、全通信を検査している。しかし、特定のAZ（アベイラビリティゾーン）間の通信だけがファイアウォールで「TCP State Violation」としてドロップされる現象が発生した。",
                        "Challenge:",
                        "TGWがパケット転送時にAZを選択するアルゴリズムと、ステートフルなファイアウォールにおいて非対称ルーティング（Asymmetric Routing）が致命的になる理由を、「行き」と「帰り」の経路差分を用いて説明せよ。",
                        "この問題を解決するためにTGWアタッチメントで有効化すべき 「Appliance Mode」 の技術的な挙動（ハッシュロジックによるフロー固定）を解説せよ。",
                        "TGWのルートテーブルにおける「Blackhole」ルートの活用例をセキュリティの観点から挙げよ。",
                        "Core Knowledge & Tech Lead's View:",
                        "非対称ルーティングの発生:",
                        "TGWはデフォルトでは、パケットの宛先等に基づき最適と判断したAZへ転送するが、往路と復路で同じAZのアタッチメント（ENI）を使う保証がない。",
                        "行き：VPC-A(AZ-a) -> TGW -> Firewall(AZ-a)",
                        "帰り：Firewall(AZ-b) -> TGW -> VPC-A(AZ-a)",
                        "ファイアウォールはAZ間でセッション情報を共有していない場合が多く（あるいは同期ラグがある）、片方向のパケットしか見ていないFWは「不正な通信」としてパケットを破棄する。",
                        "Appliance Mode:",
                        "これを有効にすると、TGWは送信元/宛先IPのハッシュ値を用いて、そのトラフィックフローを常に同じAZのアタッチメントに転送するよう固定する。これにより、行きと帰りで同じFWアプライアンスを経由することが保証される。",
                        "注意: マネジメントコンソールから設定が見えにくい場合があり、CLI/IaCでの明示的な設定が必要。",
                        "Blackholeルート:",
                        "既知の不正なCIDRや、アクセスさせたくないVPC間の通信をTGWレベルで破棄するために使用する。コストのかかるFWでのDropよりも前段で処理できる。"
                    ]
                },
                {
                    "section": "2. ネットワーキング(VPC, ELB, DX, DNS)",
                    "id": "Q8",
                    "title": "Q8. NACLのステートレス性",
                    "content": [
                        "状況: セキュリティグループは正しいのにSSHが繋がらない。ネットワークACL（NACL）でインバウンド22を許可している。",
                        "問: NACLが「ステートレス」であることに起因する、戻りパケットのための設定漏れは？"
                    ]
                },
                {
                    "section": "2. ネットワーキング(VPC, ELB, DX, DNS)",
                    "id": "Q9",
                    "title": "Q9. ELB 502 vs 504",
                    "content": [
                        "状況: ALBでエラーが発生。",
                        "ケースA: 504 Gateway Timeout",
                        "ケースB: 502 Bad Gateway",
                        "問: それぞれのエラーの原因の違いは？特に502エラーにおいて、「Webサーバー側のKeep-Alive設定」と「ALBのアイドルタイムアウト」の間にどのような不整合があると発生するか？"
                    ]
                },
                {
                    "section": "2. ネットワーキング(VPC, ELB, DX, DNS)",
                    "id": "Q10",
                    "title": "Q10. Transit Gatewayと非対称ルーティング",
                    "content": [
                        "状況: TGW経由でファイアウォールアプライアンスを通る通信がドロップされる。行きと帰りの経路が異なるAZを通っている。",
                        "問: ステートフルなファイアウォールがパケットを破棄するのを防ぐために、TGWアタッチメントで有効にすべき設定は？",
                        "ハイブリッド接続とDNS"
                    ]
                },
                {
                    "section": "2. ネットワーキング(VPC, ELB, DX, DNS)",
                    "id": "Q11",
                    "title": "Q11. Direct ConnectとMTUブラックホール",
                    "content": [
                        "状況: DX経由でPingは通るが、大きなファイルの転送やSSH接続がハングする。",
                        "問: 経路上のMTUサイズ不一致（Jumbo Frame等）と、ICMPパケットがフィルタされている場合にPath MTU Discovery (PMTUD)が失敗して起きる現象名は？"
                    ]
                },
                {
                    "section": "2. ネットワーキング(VPC, ELB, DX, DNS)",
                    "id": "Q12",
                    "title": "Q12. BGPフラッピング",
                    "content": [
                        "状況: VPN/DX接続が数分おきに切断・再接続を繰り返す。",
                        "問: ルーターログに見られる「Hold Timer Expired」の意味と、不安定な回線においてBGPのKeepalive/Hold Timeをどう調整すべきか？"
                    ]
                },
                {
                    "section": "2. ネットワーキング(VPC, ELB, DX, DNS)",
                    "id": "Q13",
                    "title": "Q13. NAT Gatewayのポート枯渇",
                    "content": [
                        "状況: プライベートサブネットから外部への接続が断続的に失敗。NAT GWのErrorPortAllocationが増加。",
                        "問: 何が枯渇しているか？S3/DynamoDBへのアクセスが原因の場合の解決策は？"
                    ]
                },
                {
                    "section": "2. ネットワーキング(VPC, ELB, DX, DNS)",
                    "id": "Q14",
                    "title": "Q14. Route 53 プライベートホストゾーンの解決",
                    "content": [
                        "状況: VPCピアリング先のVPCにあるプライベートホストゾーンの名前解決ができない。",
                        "問: ピアリング接続設定で有効にすべきオプションと、ホストゾーン自体に相手側VPCに対して行うべき操作は？",
                        "焦点: スケーリングの限界、整合性モデル、障害の連鎖。",
                        "RDS & Aurora"
                    ]
                }
            ],
            "3. データベース & ストレージ (RDS, DynamoDB, S3)": [
                {
                    "section": "3. データベース & ストレージ (RDS, DynamoDB, S3) - 上級編",
                    "id": "Q7",
                    "title": "Q7. RDS/Auroraのコネクション管理・RDS Proxy・Pinning問題",
                    "content": [
                        "PHP/LaravelアプリケーションをLambdaやFargateで大規模にスケールさせた結果、RDS (MySQL) が Too many connections でダウンした。対策として RDS Proxy を導入したが、期待したほど接続数が減らず、逆にパフォーマンスが低下したように見える。調査の結果、特定のクエリ実行時に「Pinning（ピン留め）」が発生していることが判明した。",
                        "Challenge:",
                        "max_connections パラメータがインスタンスクラスのメモリ容量に依存する理由と、メモリ枯渇が招くDBプロセスの挙動（OOM Killer等）を説明せよ。",
                        "RDS Proxyが提供する「コネクション多重化（Multiplexing）」の仕組みと、「Pinning（ピン留め）」が発生する具体的な条件（例：SETコマンド、テンポラリテーブル等）、およびそれが多重化効率を劇的に下げる理由を解説せよ。",
                        "RDS Proxyを使用することで、DBフェイルオーバー時のアプリケーションへの影響（DNS TTL待ち時間や接続エラー）をどう最小化できるか？",
                        "Core Knowledge & Tech Lead's View:",
                        "メモリと接続数:",
                        "MySQLは1接続ごとにスレッドスタックやバッファメモリを消費する。メモリ限界を超えるとスワップが発生し激重になるか、OOM Killerによりmysqldが殺される。",
                        "RDS ProxyとPinning:",
                        "通常、Proxyは大量のアプリ接続を少数のDB接続に集約（使い回し）する。",
                        "Pinning: 特定の条件（セッション変数の変更 SET @x=1、一時テーブルの作成、ユーザー定義変数の使用など）が発生すると、Proxyはそのセッションの整合性を保つため、そのアプリ接続を特定のDB接続に固定（ピン留め）してしまう。",
                        "ピン留めされた接続は他のリクエストで再利用できなくなるため、多重化の効果が消え、接続数が減らなくなる。アプリ側のコード修正で不要なSET等を排除する必要がある。",
                        "フェイルオーバー高速化:",
                        "RDS ProxyはDBの裏側でWriterの変更を検知し、アプリとの接続は維持したまま、バックエンドの接続先を新Writerへ切り替える。アプリはDNS更新や接続断を意識せず、一時的な待機だけで処理を継続できる（透過的フェイルオーバー）。"
                    ]
                },
                {
                    "section": "3. データベース & ストレージ (RDS, DynamoDB, S3) - 上級編",
                    "id": "Q8",
                    "title": "Q8. DynamoDBのホットパーティションと適応型キャパシティ",
                    "content": [
                        "DynamoDBを使用するソーシャルゲームで、特定の人気イベントIDにアクセスが集中し、ProvisionedThroughputExceededException が多発している。テーブル全体のキャパシティには余裕がある。AWSドキュメントには「適応型キャパシティ（Adaptive Capacity）が自動で偏りを解消する」とあるが、スロットリングが収まらない。",
                        "Challenge:",
                        "DynamoDBの1パーティションあたりの物理ハードリミット（3,000 RCU / 1,000 WCU / 10GB）を挙げ、これを超えるアクセスはAdaptive Capacityでも救えない理由を説明せよ。",
                        "Adaptive Capacityが有効になるまでのタイムラグ（反応速度）と、それが「瞬間的なスパイク」に対して無力である理由を述べよ。",
                        "ホットパーティション問題を根本解決するためのキー設計戦略（Write Sharding / Random Suffix）と、読み込み時のScatter-Gatherパターンのデメリットについて論ぜよ。",
                        "Core Knowledge & Tech Lead's View:",
                        "物理の壁:",
                        "Adaptive Capacityは、他のパーティションの余剰分をホットなパーティションに回す機能だが、単一の物理パーティションの上限（3,000 RCU / 1,000 WCU）を超えて処理させることは物理的に不可能。",
                        "特定のアイテム（単一のPK）へのアクセス集中は、必ず単一パーティションへの負荷になるため、ここがボトルネックになる。",
                        "Adaptive Capacityの限界:",
                        "以前より高速化したが、反応には数分〜程度の時間がかかる場合がある。秒単位のスパイク（Thundering Herd）には追いつかずスロットリングが発生する。",
                        "Sharding戦略:",
                        "解決策はアクセスを散らすこと。Partition Keyに _1, _2 ... _N のような乱数サフィックスをつけて書き込む（Write Sharding）。",
                        "読むときは、全サフィックス分（N回）並列クエリを投げて集約（Scatter-Gather）する必要があり、アプリの実装コストとReadコストが増加するトレードオフがある。"
                    ]
                },
                {
                    "section": "3. データベース & ストレージ (RDS, DynamoDB, S3) - 上級編",
                    "id": "Q9",
                    "title": "Q9. Aurora Global Databaseとレプリケーション遅延・書き込み戦略",
                    "content": [
                        "Aurora (MySQL) Global Databaseを使用し、東京（Primary）と大阪（Secondary）でDR構成を組んでいる。大阪リージョンのReaderからデータを読み込む際、東京でコミットされた直後のデータが見つからない事例がある。また、大阪リージョンから直接書き込みを行いたい要件が出てきた。",
                        "Challenge:",
                        "Auroraのストレージレイヤーにおける物理レプリケーション（Quorumモデル）と、Readerノードのページキャッシュ更新ラグによるレプリケーション遅延（数ミリ〜数十ミリ秒）のメカニズムを解説せよ。",
                        "Global DatabaseにおけるGlobal Write Forwarding（書き込み転送）機能の概要と、これを利用した際の整合性モデル（Read-after-Writeの一貫性は保証されるか？）について述べよ。",
                        "Global Databaseのフェイルオーバー（RTO）が、通常のクロスリージョンレプリケーションより劇的に速い（通常1分以内）理由を、ストレージレプリケーションの仕組みから説明せよ。",
                        "Core Knowledge & Tech Lead's View:",
                        "Auroraの遅延:",
                        "ストレージは共有されているが、Readerノードは自身のメモリ（ページキャッシュ）にデータをキャッシュしている。Writerからの「更新したよ」という無効化信号を受け取ってキャッシュを更新するまでの僅かなタイムラグが、Auroraのレプリカ遅延の正体。",
                        "Global Write Forwarding:",
                        "SecondaryリージョンのReaderで書き込みリクエストを受け取り、AWSバックボーン経由でPrimaryリージョンのWriterへ転送・実行する機能。",
                        "アプリはリージョンを意識せず書き込めるが、「書き込んだデータが即座にローカル（Secondary）のReaderで読める保証はない」（結果整合性）。書き込み完了後にレプリケーションが戻ってくるまでの遅延があるため。",
                        "高速なRTO:",
                        "Global Databaseはストレージレベルで物理ブロックを非同期転送しているため、論理レプリケーション（Binlog）よりも高速かつ低負荷。昇格（Promote）操作もストレージの役割変更だけで済むため速い。"
                    ]
                },
                {
                    "section": "3. データベース & ストレージ (RDS, DynamoDB, S3)",
                    "id": "Q15",
                    "title": "Q15. RDS Max Connections",
                    "content": [
                        "状況: 「Too many connections」エラー。",
                        "問: max_connectionsパラメータのデフォルト値は何に基づいているか？アプリケーション側でコネクションプーリングが必要な理由は？"
                    ]
                },
                {
                    "section": "3. データベース & ストレージ (RDS, DynamoDB, S3)",
                    "id": "Q16",
                    "title": "Q16. AuroraのフェイルオーバーとDNSキャッシュ",
                    "content": [
                        "状況: Auroraがフェイルオーバーしたが、アプリが古いライターへ接続を試み続けてエラーになる。",
                        "問: JavaなどのクライアントにおけるDNSキャッシュ（TTL）設定の問題点は？",
                        "DynamoDB"
                    ]
                },
                {
                    "section": "3. データベース & ストレージ (RDS, DynamoDB, S3)",
                    "id": "Q17",
                    "title": "Q17. ホットパーティション問題",
                    "content": [
                        "状況: 全体のキャパシティには余裕があるのに、特定キーへのアクセスでスロットリング発生。",
                        "問: パーティションキーの設計におけるカーディナリティ（偏り）の問題とは何か？また、Adaptive Capacity（適応型キャパシティ）が効くまでのタイムラグについて説明せよ。"
                    ]
                },
                {
                    "section": "3. データベース & ストレージ (RDS, DynamoDB, S3)",
                    "id": "Q18",
                    "title": "Q18. メタデータサービスとゴシッププロトコル",
                    "content": [
                        "状況: テーブル数やノード数が爆発的に増えた際、メタデータ管理システムが高負荷に陥る。",
                        "問: ノード間での状態共有（Membership）に使われるプロトコル名と、障害時にそれが引き起こすトラフィック増大（Storm）について説明せよ。",
                        "S3 & CloudFront"
                    ]
                },
                {
                    "section": "3. データベース & ストレージ (RDS, DynamoDB, S3)",
                    "id": "Q19",
                    "title": "Q19. S3の503 Slow Down",
                    "content": [
                        "状況: S3への大量のPUT/GETリクエストで503エラーが返る。",
                        "問: S3のパフォーマンスはバケット全体ではなく何単位で制限されるか？また、プレフィックスごとのリクエスト上限について答えよ。"
                    ]
                },
                {
                    "section": "3. データベース & ストレージ (RDS, DynamoDB, S3)",
                    "id": "Q20",
                    "title": "Q20. S3の整合性モデル（過去と現在）",
                    "content": [
                        "状況: PUT直後のGETで404になる（以前のS3）。",
                        "問: 現在のS3は強い整合性（Strong Consistency）をサポートしているが、かつての結果整合性（Eventual Consistency）時代に必要だったアプリケーション側の対策は？"
                    ]
                },
                {
                    "section": "3. データベース & ストレージ (RDS, DynamoDB, S3)",
                    "id": "Q21",
                    "title": "Q21. CloudFrontの古いコンテンツ（キャッシュ無効化）",
                    "content": [
                        "状況: S3上の静的ファイルを更新したが、ユーザーには古い画像が表示され続けている。",
                        "問: CloudFrontのエッジキャッシュを強制的に更新するために実行すべき操作（Invalidation）と、再発防止のための適切なキャッシュ戦略（ファイル名バージョニング等）について説明せよ。",
                        "焦点: 隠れたリソース制限、起動の失敗要因。",
                        "Lambda"
                    ]
                }
            ],
            "4. サーバーレス & コンテナ (Lambda, ECS, EKS)": [
                {
                    "section": "4. サーバーレス & コンテナ (Lambda, ECS, EKS) - 上級編",
                    "id": "Q10",
                    "title": "Q10. Lambda Cold Start & Concurrency Model (SnapStart)",
                    "content": [
                        "Javaで実装されたLambda関数があり、API Gateway経由で呼び出されている。不定期なアクセススパイク時に、極端なレイテンシ悪化（コールドスタート）と ThrottlingException (429) が同時に発生している。アカウントの同時実行数上限には余裕がある。",
                        "Challenge:",
                        "LambdaのBurst Concurrency（バースト同時実行数）の制限について、リージョンごとの初期バースト値（東京: 1,000など）と、それを超えた場合のスケーリング速度（毎分500インスタンス追加）の仕様を解説せよ。",
                        "Javaランタイム特有の重いコールドスタートを解消するための Lambda SnapStart の仕組み（CRaC: Checkpoint/Restore in Userspace）と、プロビジョニング済み同時実行（Provisioned Concurrency）との使い分け基準を述べよ。",
                        "Provisioned Concurrency を設定しているにもかかわらず、デプロイ直後や設定変更直後にスパイクが来るとスロットリングが発生する「初期化ラグ」の問題について触れよ。",
                        "Core Knowledge & Tech Lead's View:",
                        "Burst Limit:",
                        "アカウント上限（例: 10,000）があっても、一気に10,000まで増えるわけではない。",
                        "初期バースト（東京なら1,000）までは即座に増えるが、それ以降は 毎分500 ずつしかスケールしない。これを超える急激なスパイクは429エラーになる。",
                        "SnapStart vs Provisioned:",
                        "SnapStart: 初期化済みメモリ状態（Firecracker microVMのスナップショット）から復元して起動。無料で使える（Javaのみ）。コールドスタートを劇的に短縮するが、常時起動しているわけではない（Scale to Zero可能）。",
                        "Provisioned Concurrency: 常に指定数のWarmインスタンスを維持する（有料）。バースト制限やコールドスタートを完全に排除したい場合に必須。",
                        "初期化ラグ:",
                        "Provisioned Concurrencyの設定が完了するまで（Warm Poolが埋まるまで）数分かかる。デプロイ直後はここが弱点になりうる。"
                    ]
                },
                {
                    "section": "4. サーバーレス & コンテナ (Lambda, ECS, EKS) - 上級編",
                    "id": "Q11",
                    "title": "Q11. SQS + Lambda: Partial Failure & Poison Pill",
                    "content": [
                        "SQSをイベントソースとしてLambdaをトリガーしている。バッチサイズを10に設定しているが、そのうち1件のメッセージ処理だけがデータ不備でエラーになる。しかし、Lambda全体が失敗とみなされ、残りの正常な9件も含めて再処理（リトライ）が繰り返されている。",
                        "Challenge:",
                        "SQSトリガーのLambdaにおける「バッチ全体の失敗」のデフォルト挙動と、それを防ぐために実装すべき ReportBatchItemFailures（部分バッチ応答）の仕組みをコードレベルの返り値構造で説明せよ。",
                        "エラーになり続けるメッセージ（Poison Pill）が無限リトライされるのを防ぐための maxReceiveCount と DLQ (Dead Letter Queue) の正しい設定関係を述べよ。",
                        "Lambdaの非同期呼び出し（Event Invoke）におけるDLQ/Destinationsと、SQSトリガー（Sync Invoke扱い）におけるDLQの違いを明確にせよ。",
                        "Core Knowledge & Tech Lead's View:",
                        "ReportBatchItemFailures:",
                        "デフォルトでは、Lambdaが例外を投げるとバッチ全体（10件）がSQSに戻され、全て再処理される。",
                        "レスポンスに {\"batchItemFailures\": [{\"itemIdentifier\": \"message-id\"}]} を含めることで、失敗した特定のメッセージだけをSQSに残し、成功したメッセージは削除（Commit）させることができる。",
                        "DLQ設定:",
                        "SQS側でRedrive Policyを設定。maxReceiveCount（例: 3回）を超えたらDLQ用キューへ移動させる。",
                        "Invoke Modeの違い:",
                        "SQSトリガーは、Lambdaサービスがポーリングして関数を同期的に実行する。よってLambda関数のDLQ設定ではなく、SQSキューのDLQ設定が効く。",
                        "非同期呼び出し（S3通知等）の場合は、Lambda関数自体のDLQ/Destinations設定が使われる。"
                    ]
                },
                {
                    "section": "4. サーバーレス & コンテナ (Lambda, ECS, EKS) - 上級編",
                    "id": "Q12",
                    "title": "Q12. EKS IP Exhaustion & Fargate Profiles",
                    "content": [
                        "EKSクラスタで大量のPodを起動しようとしたところ、ノードのリソースは余っているのにIPアドレス不足でPodがPendingになった。サブネットのCIDRは/24で枯渇している。ノードを増やすこともできない。",
                        "Challenge:",
                        "VPC CNIプラグインの Warm IP / Warm ENI 戦略が、なぜIPアドレスを大量に（Pod数以上に）消費してしまうのか説明せよ。",
                        "この問題を解決するための Prefix Delegation (/28割当て) 機能の概要と、これにより1つのENIで扱えるIP数がどう変化するか述べよ。",
                        "EKS Fargate を利用する場合のIPアドレス消費モデル（PodごとのVM占有）と、EC2ノード運用と比較した際のコスト・制約（DaemonSet不可など）のトレードオフを論ぜよ。",
                        "Core Knowledge & Tech Lead's View:",
                        "Warm IP:",
                        "高速起動のため、VPC CNIはENIに付与可能なIPをあらかじめ確保（プール）しておく。デフォルトではENIの限界までIPを確保しようとするため、サブネットIPを食いつぶす。",
                        "Prefix Delegation:",
                        "ENIに個別のIPではなく、/28 プレフィックス（16個のIPブロック） を割り当てる。",
                        "1回のAPIコールで16個分のIP枠を確保でき、IP枯渇問題とAPIスロットリング問題を同時に緩和できる。",
                        "Fargateの特性:",
                        "Fargate Podは1つ1つが個別のMicroVMで動作し、個別のENIを持つ。つまりPod数 = IP消費数となる。",
                        "DaemonSetが使えないため、ログ収集や監視のエージェントをサイドカーとして全Podに入れる必要があり、リソース効率が悪化する場合がある。"
                    ]
                },
                {
                    "section": "4. サーバーレス & コンテナ (Lambda, ECS, EKS)",
                    "id": "Q22",
                    "title": "Q22. 同時実行数とスロットリング",
                    "content": [
                        "状況: Lambdaが429エラー。アカウント上限（1000等）には達していない。",
                        "問: バースト同時実行数（Burst Concurrency）の制限（リージョンごとの初期バースト値とスケーリング速度）について説明せよ。"
                    ]
                },
                {
                    "section": "4. サーバーレス & コンテナ (Lambda, ECS, EKS)",
                    "id": "Q23",
                    "title": "Q23. VPC LambdaとENI（Hyperplaneの理解）",
                    "content": [
                        "状況: VPC Lambdaの接続数が増えるとIPアドレスが枯渇する懸念。",
                        "問: 以前の仕様と異なり、現在のHyperplane ENIはどのようにENIを共有するか？それでもIP枯渇が起きるケースは？"
                    ]
                },
                {
                    "section": "4. サーバーレス & コンテナ (Lambda, ECS, EKS)",
                    "id": "Q24",
                    "title": "Q24. 非同期呼び出しとリトライストーム",
                    "content": [
                        "状況: S3トリガーのLambdaがエラーになり続け、ログが爆発的に増えている。",
                        "問: 非同期呼び出しの自動リトライ仕様（2回+キュー滞留）と、DLQ（デッドレターキュー）を設定していない場合のリスクは？",
                        "コンテナ (ECS/EKS)"
                    ]
                },
                {
                    "section": "4. サーバーレス & コンテナ (Lambda, ECS, EKS)",
                    "id": "Q25",
                    "title": "Q25. EKS IP枯渇とCNIプラグイン",
                    "content": [
                        "状況: EKSでPodがPendingのまま。ノードのリソースは余っている。",
                        "問: AWS VPC CNIプラグインのデフォルト挙動（Warm IP）が、どのようにサブネットのIPアドレスを大量消費するか？"
                    ]
                },
                {
                    "section": "4. サーバーレス & コンテナ (Lambda, ECS, EKS)",
                    "id": "Q26",
                    "title": "Q26. ECSタスク起動失敗とイメージプル",
                    "content": [
                        "状況: FargateタスクがPENDING -> STOPPEDを繰り返す。",
                        "問: プライベートサブネットでNAT GWがない場合、ECRからイメージをプルできるか？必要なVPCエンドポイントは？"
                    ]
                },
                {
                    "section": "4. サーバーレス & コンテナ (Lambda, ECS, EKS)",
                    "id": "Q27",
                    "title": "Q27. CrashLoopBackOffの調査",
                    "content": [
                        "状況: Podが再起動を繰り返す。現在のログを見ても何も出ていない。",
                        "問: 直前のクラッシュ時のログを見るためのkubectlオプションは？",
                        "焦点: 権限不足の特定、IAMロールの仕様。"
                    ]
                }
            ],
            "5. IAM & セキュリティのトラブルシューティング": [
                {
                    "section": "5. IAM & セキュリティのトラブルシューティング - 上級編",
                    "id": "Q13",
                    "title": "Q13. Circuit Breaker & Bulkhead Patterns",
                    "content": [
                        "外部の決済APIが遅延し始め、呼び出し元のECSサービスの全スレッドが待機状態（Blocked）になり、ヘルスチェックすら応答できずにシステムダウン（Cascading Failure）した。再起動しても即座にまた詰まる。",
                        "Challenge:",
                        "Circuit Breaker パターンの3状態（Closed、 Open, Half-Open）の遷移ロジックに加え、Fail Fast（即時失敗）がシステム全体の生存になぜ不可欠なのか解説せよ。",
                        "サーキットブレーカーだけでは防げない「リソース枯渇」に対処するための Bulkhead（隔壁）パターン の実装方法（スレッドプール分離やセマフォ分離）を述べよ。",
                        "AWS App MeshやEnvoyプロキシの Outlier Detection（外れ値検知） 機能を用いて、インフラ層でこれを自動化する方法について触れよ。",
                        "Core Knowledge & Tech Lead's View:",
                        "Fail Fast:",
                        "ダメな時は待たずに即エラーを返すこと。タイムアウトまで待つ（ブロッキングする）時間が、スレッドやメモリを占有し、他の健全な処理まで道連れにする。",
                        "Bulkhead:",
                        "船の隔壁のようにリソースを区切る。決済API用のスレッドプールと、ヘルスチェック/Topページ用のスレッドプールを分ける。これにより決済APIが死んでもTopページは生き残る。",
                        "Outlier Detection:",
                        "Envoyなどのプロキシが、連続して5xxを返すアップストリームホストを一時的に切り離す（Ejection）機能。アプリコードを変更せずにサーキットブレーカー相当の動きを実現できる。"
                    ]
                },
                {
                    "section": "5. IAM & セキュリティのトラブルシューティング - 上級編",
                    "id": "Q14",
                    "title": "Q14. Static Stability & Route 53 ARC",
                    "content": [
                        "AWSのリージョン規模の障害（Control Plane障害）が発生し、EC2の新規起動やAuto Scaling、Route 53のAPI変更ができない状況に陥った。しかし、経営陣は「稼働中のリソースだけでサービスを継続せよ」と要求している。",
                        "Challenge:",
                        "Static Stability（静的安定性） の概念を定義し、障害発生時に「コントロールプレーン（設定変更）」に依存しないアーキテクチャがいかにして可用性を高めるか説明せよ。",
                        "Route 53 Application Recovery Controller (ARC) の機能（ゾーンシフトやルーティングコントロール）が、従来のヘルスチェックベースのDNSフェイルオーバーと比べて、なぜより確実な復旧手段となり得るのか論ぜよ。",
                        "静的安定性を実現するためのコスト（Over-provisioning）は「保険料」であるが、リザーブドインスタンスやSavings Plans、Spot Instancesをどう組み合わせればコストを最適化しつつ冗長性を維持できるか？",
                        "Core Knowledge & Tech Lead's View:",
                        "Static Stability:",
                        "「障害が起きてからスケールする（Reactive）」のではなく、「障害が起きてもそのままで耐えられる」状態。",
                        "例: 3AZ構成で1AZがダウンしても、残りの2AZだけでトラフィックを捌けるよう、平時から50%余分に（合計150%の）リソースを稼働させておく。",
                        "障害時はAPI（RunInstances）自体が失敗する可能性が高いため、既存のリソース（Data Plane）だけで戦うのが最強。",
                        "Route 53 ARC:",
                        "ヘルスチェックは「偽陽性（False Positive）」や「フラッピング」のリスクがある。",
                        "ARCは、人間または自動システムが明示的に「スイッチを切り替える」ことで、DNSの重み付けを安全かつ確実に変更する仕組み。コントロールプレーンの依存を排除した特殊なデータプレーンで動作する。"
                    ]
                },
                {
                    "section": "5. IAM & セキュリティのトラブルシューティング - 上級編",
                    "id": "Q15",
                    "title": "Q15. Thundering Herd & Jitter / Idempotency",
                    "content": [
                        "大規模障害から復旧した瞬間、数百万のクライアントが一斉に再接続（Reconnect）を試み、データベースとロードバランサーが即死した（Thundering Herd問題）。また、リトライによって二重決済が発生している。",
                        "Challenge:",
                        "クライアント側のリトライロジックにおける Exponential Backoff だけでは不十分で、Jitter（ゆらぎ） を加えることが数学的に必須である理由を説明せよ。",
                        "分散システムにおける 冪等性（Idempotency） の担保戦略として、APIリクエストに含めるべき Idempotency Key の役割と、サーバー側（DynamoDBやRedis）での実装パターン（TTL付きロック等）を設計せよ。",
                        "サーバー側での防御策としての Load Shedding（負荷制限・切り捨て） の重要性と、AWS WAFやAPI Gatewayでの実装例を挙げよ。",
                        "Core Knowledge & Tech Lead's View:",
                        "Jitter:",
                        "指数バックオフ（1秒, 2秒, 4秒...）だけだと、全員が同じタイミングで待って同じタイミングで再試行するため、負荷の「波」が消えない。",
                        "ランダムな時間を加える（Jitter）ことで、アクセスを時間の軸で平準化・分散させる。",
                        "Idempotency Key:",
                        "クライアントがリクエスト時に一意なID（UUID等）を付与。",
                        "サーバーは「このIDは処理済みか？」をKVS等で確認。処理済みなら実際の処理をスキップして、前回と同じ成功レスポンスを返す。",
                        "これにより、タイムアウト時のリトライによる二重処理（二重課金）を安全に防げる。"
                    ]
                },
                {
                    "section": "5. IAM & セキュリティのトラブルシューティング - 上級編",
                    "id": "Q16",
                    "title": "Q16. Blast Radius & Cellular Architecture",
                    "content": [
                        "ある一人のヘビーユーザー（または設定ミスのテナント）が共有リソースを食いつぶし、全ユーザーに影響が出る大規模障害が発生した。これを防ぐために Cell-based Architecture（セルラーアーキテクチャ） への移行を検討している。",
                        "Challenge:",
                        "Cellular Architecture の基本概念と、シャーディング（DB分割）との決定的な違い（スタック全体の垂直分割）を説明せよ。",
                        "セルラー構成における Routing Layer（薄いルーティング層） の設計課題と、Route 53やCloudFront Functionsを用いてユーザーを正しいセルに導く方法を提案せよ。",
                        "セルラーアーキテクチャが Blast Radius（爆発半径） を最小化するメカニズムと、デプロイメントの安全性（1セルずつデプロイ）への寄与について論ぜよ。",
                        "Core Knowledge & Tech Lead's View:",
                        "Cellular Architecture:",
                        "システム全体（LB、 Web、 App, DB、 Queue）を独立した「セル」という単位に分割して並列化する。",
                        "シャーディングはDBだけだが、セルは全スタックを隔離する。あるセルが死んでも、影響はそのセル内のユーザー（例: 全体の5%）に限定される。",
                        "Routing:",
                        "「誰がどのセルにいるか」を知るためのマッピングが必要。",
                        "最も堅牢なのは、計算不要な静的なパーティション（例：ユーザーIDのハッシュ値）を使い、Route 53やCloudFront Edgeで振り分ける方法。ルーティング層自体がSPOFにならないように極限までシンプルにする（Simple is reliable）。"
                    ]
                },
                {
                    "section": "5. IAM & セキュリティのトラブルシューティング",
                    "id": "Q28",
                    "title": "Q28. 権限不足のデバッグ",
                    "content": [
                        "状況: アプリケーションがS3へのアクセスでAccess Deniedになる。",
                        "問: CloudTrailで該当のAPIコールを検索し、どのポリシー（アイデンティティベース、リソースベース、SCP）が拒否しているか特定する手順は？"
                    ]
                },
                {
                    "section": "5. IAM & セキュリティのトラブルシューティング",
                    "id": "Q29",
                    "title": "Q29. iam:PassRole",
                    "content": [
                        "状況: EC2インスタンスを起動する権限はあるが、インスタンスにIAMロールを割り当てようとするとエラーになる。",
                        "問: ロールをAWSサービスに渡すためのiam:PassRole権限の必要性について説明せよ。",
                        "焦点: 過去のPost-Mortemから学ぶ、カスケード障害と静的安定性。",
                        "過去の大規模障害から学ぶ"
                    ]
                }
            ],
            "6. 大規模障害ケーススタディ & レジリエンス": [
                {
                    "section": "6. 大規模障害ケーススタディ & レジリエンス",
                    "id": "Q17",
                    "title": "Q17. S3 Strong Consistency & Data Lake Performance",
                    "content": [
                        "S3をデータレイクとして使用し、Athenaで分析している。以前は「書き込み直後の読み込み」でデータが見えない問題（結果整合性）があったが、現在は解消されているはずだ。しかし、大量の小さなファイルをPUTした直後にLIST操作を行うとパフォーマンスが出ない。",
                        "Challenge:",
                        "現在のS3が提供する Strong Consistency（強い整合性） の仕様（PUT/DELETE後のREAD/LIST）について、正確に述べよ。",
                        "S3のパフォーマンスにおける Prefix（プレフィックス） の重要性と、かつて必要だった「ハッシュ化プレフィックス」が現在では不要になった理由、および現在のスケーリング仕様（1プレフィックスあたりのTPS: 3,500 PUT / 5,500 GET）を解説せよ。",
                        "大量の小ファイル問題（Small File Problem）がAthena/Sparkのパフォーマンスに与える悪影響と、これを解決するための S3 DistCp やETL処理でのファイル結合（Compaction）の重要性を説け。",
                        "Core Knowledge & Tech Lead's View:",
                        "Strong Consistency: 2020年末より、S3は全てのPUT/DELETE操作に対して強い整合性を持つようになった。書き込み直後のGETやLISTは常に最新の結果を返す。",
                        "Partitioning: S3は自動的にプレフィックスに基づいてパーティションを分割・スケールさせる。現在はハッシュ化不要で、順次プレフィックス（日付等）でも自動でスケールするが、急激なスパイクには 503 Slow Down が出る場合がある。",
                        "Small Files: S3/Athenaは数KBのファイルを数百万個読むのが苦手（APIコール数とレイテンシのオーバーヘッド）。MB〜GB単位にまとめる（Compaction）のが鉄則。"
                    ]
                },
                {
                    "section": "6. 大規模障害ケーススタディ & レジリエンス",
                    "id": "Q18",
                    "title": "Q18. Gateway Load Balancer (GWLB) & Inspection",
                    "content": [
                        "セキュリティ要件により、VPCに出入りする全トラフィックをサードパーティ製のファイアウォールアプライアンス（Palo Alto、 FortiGate等）で検査したい。従来はTGWやVPN接続が必要だったが、構成が複雑でボトルネックになりやすい。",
                        "Challenge:",
                        "Gateway Load Balancer (GWLB) が提供する「Bump-in-the-wire（透過的検査）」アーキテクチャの仕組みを、GENEVEプロトコルとルートテーブルのターゲット指定（Gateway Load Balancer Endpoint: GWLBE）を用いて解説せよ。",
                        "GWLBを使用することで、アプライアンスのオートスケーリングやヘルスチェックが容易になる理由を、従来のEC2ベースのFW構成と比較して述べよ。",
                        "Ingress Routing（インターネットからの流入）において、Internet Gateway (IGW) のルートテーブルで Ingress Routing（Edge Association） を設定し、トラフィックをGWLBEに強制的に引き込む手法を説明せよ。",
                        "Core Knowledge & Tech Lead's View:",
                        "GWLB: L3（ネットワーク層）で動作し、パケットをカプセル化（GENEVE）して裏側のFWフリートに投げる。FWはパケットを検査してそのまま返す。",
                        "透過性: アプリ側や通信相手からは、間にGWLB/FWがいることは見えない（IPが変わらない）。NATも不要。",
                        "Ingress Routing: IGWに関連付けたルートテーブルで、Dest: Subnet-CIDR -> Target: GWLBE と書くことで、外から入ってきたパケットを強制的に検査装置へねじ曲げることができる。"
                    ]
                },
                {
                    "section": "6. 大規模障害ケーススタディ & レジリエンス",
                    "id": "Q19",
                    "title": "Q19. Container Insights & Observability",
                    "content": [
                        "EKS上でマイクロサービスを運用しているが、PodがOOMKilled（メモリ不足で強制終了）されていることに気づくのが遅れた。CloudWatchの標準メトリクスではノード全体のCPU/メモリしか見えず、Pod単位の特定が困難である。",
                        "Challenge:",
                        "CloudWatch Container Insights を有効化することで収集されるメトリクスの粒度（Cluster、 Node、 Pod、 Service）と、その背後で動くエージェント（CloudWatch Agent / Fluent Bit）の役割を説明せよ。",
                        "OOMKilled のようなイベントを即座に検知するために、Container Insightsのメトリクス（pod_memory_utilization等）やログパターン監視（Reason: OOMKilled）をどう設定すべきか。",
                        "プロメテウス（Amazon Managed Service for Prometheus）とGrafanaを用いたOSSベースの監視スタックと、Container Insightsの使い分け（コスト、手軽さ、詳細度）についてTech Leadとしての推奨を述べよ。",
                        "Core Knowledge & Tech Lead's View:",
                        "Container Insights: Fluent Bit等がコンテナランタイムやkubeletから詳細情報を吸い上げ、構造化データとしてCloudWatchに送る。Pod単位のリソース使用率が見えるようになる。",
                        "OOM検知: メモリ使用率監視だけでは不十分（スパイクで死ぬため）。K8sイベントログやアプリログで OOMKilled 文字列を監視し、アラートを飛ばすのが確実。",
                        "Prometheus vs CW: 大規模クラスタで全PodのメトリクスをCWに送るとコストが爆発する（Custom Metrics課金）。大規模環境ではPrometheusの方が安価で柔軟な場合が多い。小規模ならCW Container Insightsが手軽。"
                    ]
                },
                {
                    "section": "6. 大規模障害ケーススタディ & レジリエンス",
                    "id": "Q20",
                    "title": "Q20. Security Hub & GuardDuty: Continuous Compliance",
                    "content": [
                        "複数のAWSアカウントを持つ組織で、セキュリティ基準（PCI DSSやCIS Benchmark）の遵守状況を可視化したい。また、アクセスキーの漏洩やコインマイニングなどの脅威をリアルタイムで検知したい。",
                        "Challenge:",
                        "Amazon GuardDuty が検知できる脅威の種類（VPC Flow Logs、 CloudTrail、 DNS Logsの分析）と、これがエージェントレスで動作するメリットを述べよ。",
                        "AWS Security Hub が提供する「一元管理」と「自動修復（Automated Remediation）」の機能を、EventBridgeとLambdaを組み合わせたアーキテクチャで説明せよ（例：意図しないSG開放を検知して即座に閉じる）。",
                        "組織全体（AWS Organizations）でこれらのセキュリティサービスを有効化する際のベストプラクティス（委任管理者: Delegated Administratorの設定）について触れよ。",
                        "Core Knowledge & Tech Lead's View:",
                        "GuardDuty: ログを機械学習で分析し、異常な通信（C&Cサーバーへの接続）やIAMの異常なAPIコールを検知。エージェント不要なので全アカウントで即ONにすべき（必須）。",
                        "Security Hub: 各種セキュリティサービス（GuardDuty、 Inspector, Macie）のアラートを集約し、CISベンチマーク等のスコアを表示する。",
                        "自動修復: Security Hubの検知イベント -> EventBridge -> Lambda で、「SGの22番ポート開放"
                    ]
                },
                {
                    "section": "6. 大規模障害ケーススタディ & レジリエンス (SRE/Principal)",
                    "id": "Q30",
                    "title": "Q30. 2020年 Kinesis障害とカスケード",
                    "content": [
                        "状況: Kinesisの障害により、CognitoやCloudWatch、Auto Scalingまでもが連鎖的に機能不全に陥った。",
                        "問: なぜKinesisの障害が他のサービスに波及したのか？「フリート全体の最大スレッド数超過」と「循環依存」の観点から説明せよ。"
                    ]
                },
                {
                    "section": "6. 大規模障害ケーススタディ & レジリエンス (SRE/Principal)",
                    "id": "Q31",
                    "title": "Q31. 2017年 S3障害と爆発半径",
                    "content": [
                        "状況: コマンド入力ミスにより、想定以上のS3サブシステムサーバーが削除され、リージョン障害に発展。",
                        "問: この教訓から生まれた、運用ツールにおける「爆発半径（Blast Radius）の最小化」や「セルラーアーキテクチャ」とは？"
                    ]
                },
                {
                    "section": "6. 大規模障害ケーススタディ & レジリエンス (SRE/Principal)",
                    "id": "Q32",
                    "title": "Q32. 2021年 US-EAST-1障害と内部DNS",
                    "content": [
                        "状況: 内部ネットワークの輻輳により、AWS内部DNSの解決が失敗し、APIエラーが多発。",
                        "問: サービス間通信においてDNS解決に依存することのリスクと、データプレーンの静的安定性（Static Stability）の重要性は？",
                        "運用戦略"
                    ]
                },
                {
                    "section": "6. 大規模障害ケーススタディ & レジリエンス (SRE/Principal)",
                    "id": "Q33",
                    "title": "Q33. Thundering Herd（再開の波）対策",
                    "content": [
                        "状況: 障害復旧直後、待機していたリクエストが一斉に殺到し、DBが再度ダウン（ブラウンアウト）。",
                        "問: クライアント側のリトライロジックに入れるべきExponential BackoffとJitter（ゆらぎ）の効果は？"
                    ]
                },
                {
                    "section": "6. 大規模障害ケーススタディ & レジリエンス (SRE/Principal)",
                    "id": "Q34",
                    "title": "Q34. サーキットブレーカー",
                    "content": [
                        "状況: 依存する外部APIが遅延し、自システムの全スレッドが待機状態で埋め尽くされた。",
                        "問: 障害のある依存先を即座に切り離し、即時エラーを返すことで自システムを守るデザインパターンは？",
                        "焦点: 見落としがちな仕様、泥臭い運用回避策。"
                    ]
                }
            ],
            "7. その他・運用Tips (Cost, Ops)": [
                {
                    "section": "7. その他・運用Tips (Cost, Ops)",
                    "id": "Q35",
                    "title": "Q35. Windows RDPパスワード取得不可",
                    "content": [
                        "状況: Windowsインスタンス起動後、「パスワードはまだ使用できません」と表示され続ける。",
                        "問: インスタンス内部で動いている、パスワード生成に必要な初期化サービスの名前は？"
                    ]
                },
                {
                    "section": "7. その他・運用Tips (Cost, Ops)",
                    "id": "Q36",
                    "title": "Q36. サポートケース起票の鉄則",
                    "content": [
                        "状況: 技術サポートに調査を依頼するが、解決が遅い。",
                        "問: 初回の問い合わせで必ず含めるべき、調査時間を短縮するための3つの具体的情報は？"
                    ]
                },
                {
                    "section": "7. その他・運用Tips (Cost, Ops)",
                    "id": "Q37",
                    "title": "Q37. 終了保護の罠",
                    "content": [
                        "状況: 終了保護（Termination Protection）を有効にしたインスタンスが、Auto Scalingのスケールイン時に削除されてしまった。",
                        "問: なぜか？ASG側で設定すべき項目は？"
                    ]
                },
                {
                    "section": "7. その他・運用Tips (Cost, Ops)",
                    "id": "Q38",
                    "title": "Q38. コスト急増の犯人探し",
                    "content": [
                        "状況: データ転送量が急増し高額請求が来た。",
                        "問: VPCフローログ以外に、S3へのアクセス（APIコール数や転送量）を詳細に分析するために有効にする機能は？"
                    ]
                }
            ]
        };

        function QuizPage() {
            const route = Router.getRoute();
            const quizType = route.query.type || 'aws';
            
            let pageTitle = 'AWS問題集';
            if (quizType === 'pm') pageTitle = 'PM問題集';
            if (quizType === 'quality') pageTitle = '品質・プロセス問題集';
            
            setMeta(`${pageTitle} | Portfolio`, pageTitle);
            const box = h("div", { class: "col", style: { gap: '14px', maxWidth: '1100px', margin: '0 auto' } });

            box.appendChild(h("div", { class: "h2", text: pageTitle }));

            const awsQuizData = {
                "1. コンピュート & インスタンス (EC2, EBS)": [
                    {
                        "section": "1. コンピュート & インスタンス (EC2, EBS)",
                        "id": "Q1",
                        "title": "Q1. ステータスチェックの厳密な切り分け",
                        "content": [
                            "状況: EC2が応答しない。「システムステータスチェック」が失敗している。",
                            "問: 再起動（Reboot）ではなく「停止・開始（Stop/Start）」を選択すべき技術的理由は何か？この操作によってAWS内部で何が行われるか？"
                        ]
                    },
                    {
                        "section": "1. コンピュート & インスタンス (EC2, EBS) - 上級編",
                        "id": "Q1",
                        "title": "Q1. インスタンス障害の厳密な切り分けとリカバリ・自動化戦略",
                        "content": [
                            "本番稼働中のEC2インスタンス（Linux）へのSSH接続がタイムアウトし、サービス応答も途絶えた。CloudWatchを確認すると「システムステータスチェック（System Status Check）」が失敗している。一方で「インスタンスステータスチェック」は成功しているように見える。このインスタンスはASG（Auto Scaling Group）管理下にあるが、なぜか自動復旧していない。",
                            "Challenge",
                            "「システムステータスチェック」と「インスタンスステータスチェック」の失敗が示す物理的・論理的な責任境界を、ハイパーバイザーとOSのレイヤーから厳密に定義せよ。",
                            "この状況で、オペレーターが手動で Reboot を実行しても問題が解決しない可能性が高い技術的理由と、Stop/Start が物理ホストレベルで何を引き起こすか（Migrationメカニズム）を解説せよ。",
                            "ASGのヘルスチェックタイプが「EC2」であるにもかかわらず、システムステータスチェック失敗時に即座に置換されないケースがある。ASGがEC2の不調を検知してインスタンスを置換するための正確な条件と、「EC2 Auto Recovery」との機能的な違いを述べよ。",
                            "Core Knowledge & Tech Lead's View:",
                            "境界点:",
                            "システムステータスチェック: AWS側の責任範囲。物理ホストの電源、ネットワーク接続、物理ディスク、またはハイパーバイザー（Nitro System等）自体の障害を示す。ユーザーの操作では修復不可能。",
                            "インスタンスステータスチェック: ユーザー側の責任範囲。ゲストOSのカーネルパニック、ファイルシステム破損、ネットワーク設定ミス（iptables/NIC設定）、メモリ枯渇によるプロセスハングなどが原因。",
                            "Reboot vs Stop/Start:",
                            "Reboot は同一物理ホスト上でのOS再起動に過ぎないため、物理ホスト自体（システムステータス）に障害がある場合は復旧しない。",
                            "Stop はインスタンスと物理ホストの紐付けを解除し、Start は健全な別の物理ホストへインスタンスを新規配置（Migration）する操作であるため、物理障害からの確実な回避策となる。",
                            "注意: インスタンスストア（Ephemeral Storage）のデータはStopにより完全に消失する。",
                            "ASG vs Auto Recovery:",
                            "ASGの「EC2」ヘルスチェックは、ステータスチェック失敗を検知してインスタンスをTerminate & Replace（削除して新規作成）する。ステートフルなデータは消える。",
                            "EC2 Auto Recoveryは、インスタンスをTerminateせず、同じインスタンスID、同じEBSボリューム、同じEIPを保持したままStop/Start相当の復旧（物理ホスト移動）を自動で行う。",
                            "現場の視点: 単なるWebサーバーならASGの置換で良いが、固定IPや特定EBSが必要な管理サーバー等はEC2 Auto Recoveryを設定すべき。"
                        ]
                    },
                    {
                        "section": "1. コンピュート & インスタンス (EC2, EBS)",
                        "id": "Q2",
                        "title": "Q2. インスタンスステータスチェック失敗時のレスキュー",
                        "content": [
                            "状況: 「インスタンスステータスチェック」が失敗し、SSHも繋がらない。重要データがありTerminateできない。",
                            "問: ログ調査とファイルシステム修復のために行う「レスキューインスタンス」の手順とは？"
                        ]
                    },
                    {
                        "section": "1. コンピュート & インスタンス (EC2, EBS) - 上級編",
                        "id": "Q2",
                        "title": "Q2. EBS (gp2/gp3/io2) のパフォーマンス仕様とスループットの罠",
                        "content": [
                            "レガシーなDBサーバーで gp2 ボリューム（500GB）を使用している。IOPS上限（1,500 IOPS）には達していないが、バッチ処理中にディスクレイテンシが悪化し、CloudWatchの BurstBalance が0%に張り付いている。コスト削減と性能安定のため gp3 への移行を計画したが、移行後にIOPSは足りているはずなのに、逆に処理時間が2倍に延びる障害が発生した。",
                            "Challenge:",
                            "gp2 における「クレジットバケツモデル」の計算式（ベースラインIOPSと蓄積レート）に基づき、500GBボリュームがバースト枯渇を起こすメカニズムを数値で証明せよ。",
                            "gp3 移行時に多くのエンジニアが見落とす「スループット（MiB/s）」のデフォルト制限値と、それがDBのシーケンシャルリード/ライトに与える影響を説明せよ。",
                            "ミッションクリティカルなDBにおいて、gp3 ではなくあえて io2 Block Express を選択すべき技術的条件（レイテンシ、耐久性、マルチアタッチ）を挙げよ。",
                            "Core Knowledge & Tech Lead's View:",
                            "gp2の枯渇:",
                            "ベースラインは 3 IOPS/GB。500GBの場合、500 * 3 = 1,500 IOPS がベースライン。",
                            "3,000 IOPSまでバースト可能だが、ベースラインを超過中はクレジットを消費する。クレジットが枯渇すると、強制的に1,500 IOPSに制限（スロットリング）される。",
                            "gp3の罠 (Throughput):",
                            "gp3 はベースライン3,000 IOPSを保証するが、スループットのデフォルトは 125 MiB/s である。",
                            "一方、gp2 (500GB) のスループット上限はバースト時 250 MiB/s まで出る仕様になっている（容量依存）。",
                            "失敗原因: 移行時にスループット設定をデフォルト（125 MiB/s）のままにしたため、帯域幅が半分になり、大量のデータを読み書きするバッチ処理が遅延した。gp3では明示的にスループットを追加購入する必要がある。",
                            "io2 Block Expressの出番:",
                            "サブミリ秒の低レイテンシが必要な場合。",
                            "99.999% (ファイブナイン) の耐久性が必要な場合（gp3は99.8-99.9%）。",
                            "Multi-Attach（複数のEC2から同時に書き込み可能なクラスタ構成）が必要な場合。"
                        ]
                    },
                    {
                        "section": "1. コンピュート & インスタンス (EC2, EBS)",
                        "id": "Q3",
                        "title": "Q3. インスタンスストアの揮発性",
                        "content": [
                            "状況: インスタンスストア（Ephemeral Storage）を持つインスタンスタイプ（i3など）をStop/Startした。",
                            "問: インスタンスストア内のデータはどうなるか？また、Rebootの場合はどうなるか？",
                            "リソースとパフォーマンス"
                        ]
                    },
                    {
                        "section": "1. コンピュート & インスタンス (EC2, EBS) - 上級編",
                        "id": "Q3",
                        "title": "Q3. インスタンス起動時のデバッグとUser Data",
                        "content": [
                            "Auto Scaling Groupで起動したインスタンスが、アプリの起動スクリプト（User Data）のエラーにより Unhealthy と判定され、ログを確認する前にTerminateされてしまう現象がループしている。User DataはBase64エンコードされており、手動デコードしても構文エラーは見当たらない。",
                            "Challenge:",
                            "起動失敗したインスタンスをTerminateさせずに一時停止（Pending:Wait / Terminating:Wait）させ、デバッグを行うためのASG機能とその具体的な設定フック名を答えよ。",
                            "Linuxにおける cloud-init の実行フェーズ（init、 config、 final）において、User Data（シェルスクリプト）はどの段階で実行されるか？ また、標準出力・エラー出力が記録される完全なログパスを示せ。",
                            "User Dataが正しく記述されているにもかかわらず、スクリプトが途中終了したり実行されない場合によくある、「改行コード」や「シェバン（#!）」にまつわるトラブル原因を挙げよ。",
                            "Core Knowledge & Tech Lead's View:",
                            "Lifecycle Hooks:",
                            "ASGの Lifecycle Hook を設定する。",
                            "起動時デバッグなら autoscaling:EC2_INSTANCE_LAUNCHING フックで、遷移を Pending:Wait 状態で止める。これによりSSH/SSMでログインして調査が可能になる。",
                            "cloud-initの動作:",
                            "User Data（シェルスクリプト）は通常 final フェーズ（起動処理の最後）で実行される。",
                            "ログファイル: /var/log/cloud-init-output.log（スクリプトの標準出力/エラー出力はここ）。構造化ログは /var/log/cloud-init.log。",
                            "現場の罠:",
                            "Windowsで作成したファイルの改行コードが CRLF になっていると、Linuxのbashが解釈できずエラーになる（LF必須）。",
                            "#!/bin/bash のシェバンがないと、cloud-initがスクリプトとして認識しない場合がある。",
                            "Tech Lead's Tip: 本番でASGを止めるより、同じAMIとUser Dataを使って手動で単発インスタンスを起動し、再現確認するほうが安全かつ迅速な場合が多い。"
                        ]
                    },
                    {
                        "section": "1. コンピュート & インスタンス (EC2, EBS)",
                        "id": "Q4",
                        "title": "Q4. T系インスタンスとCPUクレジット",
                        "content": [
                            "状況: T3インスタンスのCPU使用率が20%で張り付き、極端に遅い。",
                            "問: 確認すべきメトリクスはCPUCreditBalanceだが、これを即座に解決するために有効にするモードは？また、そのコストへの影響は？"
                        ]
                    },
                    {
                        "section": "1. コンピュート & インスタンス (EC2, EBS)",
                        "id": "Q5",
                        "title": "Q5. EBSの初期化（ハイドレーション）",
                        "content": [
                            "状況: S3のスナップショットから復元した大容量EBSボリュームが、使用開始直後に激しいレイテンシを示す。",
                            "問: S3からの遅延読み込み（Lazy Loading）によるパフォーマンス低下を防ぐために、使用前に実行すべき操作は？"
                        ]
                    },
                    {
                        "section": "1. コンピュート & インスタンス (EC2, EBS)",
                        "id": "Q6",
                        "title": "Q6. EBSバーストバランス枯渇",
                        "content": [
                            "状況: gp2ボリュームでIOPS制限には達していないが、I/O待ちが増加している。",
                            "問: gp2特有のBurstBalanceメトリクスとは何か？これが枯渇した時の挙動と、gp3への移行メリットは？"
                        ]
                    },
                    {
                        "section": "1. コンピュート & インスタンス (EC2, EBS)",
                        "id": "Q7",
                        "title": "Q7. OSレベルの制限（No space left on device）",
                        "content": [
                            "状況: ディスク容量不足のエラーが出るが、df -hで見ると容量は余っている。",
                            "問: 容量（ブロック）以外に枯渇している可能性があるファイルシステムのリソースは？確認コマンドは？",
                            "焦点: パケットの消失、非対称ルーティング、DNSの挙動。",
                            "接続性とファイアウォール"
                        ]
                    }
                ],
                "2. ネットワーキング(VPC, ELB, DX, DNS)": [
                    {
                        "section": "2. ネットワーキング(VPC, ELB, DX, DNS) - 上級編",
                        "id": "Q4",
                        "title": "Q4. Security Group vs NACL: ステート管理と戻り通信の落とし穴",
                        "content": [
                            "特定の攻撃的なIPアドレス群からのアクセスをVPCレベルで遮断するため、ネットワークACL（NACL）でInbound DENYルールを設定した。しかし、設定直後から、そのサブネット内のサーバーが外部のリポジトリ（yum/apt）に接続できなくなり、サーバー監視のエージェントもタイムアウトし始めた。SG（セキュリティグループ）の設定は変更していない。",
                            "Challenge:",
                            "SGが「ステートフル」、NACLが「ステートレス」であることを踏まえ、NACLでのInbound遮断が、なぜ無関係なOutbound通信（外部へのリクエスト）の応答パケットに影響を与えるのか、エフェメラルポート（Ephemeral Ports）の挙動を用いて解説せよ。",
                            "サーバーから外部へ通信する場合、NACLのInbound/Outboundルールに最低限どのような許可設定が必要か？ TCPハンドシェイクの往復（SYN -> SYN/ACK -> ACK）に基づいて説明せよ。",
                            "Kubernetes (EKS) 環境において、Pod単位でSGを割り当てる機能（Security Groups for Pods）を使用する場合、ノードレベルのNACL設定との競合や制約について考慮すべき点は何か。",
                            "Core Knowledge & Tech Lead's View:",
                            "戻り通信の死:",
                            "NACLはステートレスなので、「行き」を許可しても「帰り」は自動許可されない。",
                            "サーバーが外部（yumリポジトリ等）へリクエストを送る際、送信元ポートとして エフェメラルポート（1024-65535等） を使用する。",
                            "外部からの応答（SYN/ACK）は、このエフェメラルポート宛てに戻ってくる。",
                            "もしNACLのInboundルールで、特定の攻撃IPを拒否するルールを追加した際、誤ってデフォルトの「Allow ALL」より優先順位が高い位置で広い範囲を拒否していたり、あるいは戻りのエフェメラルポート範囲を明示的に許可していなければ、正規の戻りパケットがドロップされる。",
                            "TCPハンドシェイク:",
                            "Outbound: Server -> External (Dst: 443, Src: 32768) [SYN] -> NACL Outbound許可が必要",
                            "Inbound: External -> Server (Dst: 32768, Src: 443) [SYN/ACK] -> NACL Inboundでポート1024-65535の許可が必要",
                            "EKSのSG:",
                            "Security Groups for Podsを使っても、通信は依然としてサブネットのNACLを通過する。NACLが厳しすぎるとPod通信も阻害される。",
                            "Tech Lead's View: NACLは「特定の攻撃IPを緊急ブロックする」等の用途に限定し、基本はAllow ALLで運用すべき。複雑なNACLはデバッグ不可能な障害を生む。"
                        ]
                    },
                    {
                        "section": "2. ネットワーキング(VPC, ELB, DX, DNS) - 上級編",
                        "id": "Q5",
                        "title": "Q5. DNS at Scale: VPC Resolverの制限とハイブリッドDNS",
                        "content": [
                            "マイクロサービスアーキテクチャを採用し、サービス間通信にDNSベースのサービスディスカバリを使用している。負荷テストを実施したところ、間欠的に名前解決エラー（NameResolutionError）が発生し始めた。また、オンプレミスとDirect Connectで接続された環境で、オンプレ側のDNSサーバーにあるドメインがVPCから引けない問題も発生している。",
                            "Challenge:",
                            "VPC内部DNSリゾルバ（169.254.169.253）に存在する ハードリミット（PPS制限） の具体的な数値と、それがネットワークインターフェース（ENI）単位であることを踏まえた対策（NodeLocal DNSCacheなど）を述べよ。",
                            "Route 53 Resolverの Outbound Endpoint と Forwarding Rule を用いて、VPCからオンプレミスのDNSを解決するアーキテクチャを説明せよ。逆に、オンプレからVPC内のPrivate Hosted Zoneを解決するには何が必要か？",
                            "DNSラウンドロビンによるロードバランシングの限界（クライアントサイドのキャッシュ挙動やスティッキー性）と、それを解決するための最新のサービスディスカバリ手法（AWS Cloud Map、 Envoy等）について論ぜよ。",
                            "Core Knowledge & Tech Lead's View:",
                            "PPS制限:",
                            "VPC DNSへのクエリは 1024 パケット/秒 (PPS) / ENI というハードリミットがある。",
                            "マイクロサービスで短命な接続を大量に繰り返すとこれに抵触する。",
                            "対策: Kubernetesなら NodeLocal DNSCache を導入し、各ノード上でDNSキャッシュを行うことでVPCリゾルバへの問い合わせを減らす。アプリ側でもDNS TTLを適切に扱う。",
                            "ハイブリッドDNS:",
                            "VPC -> On-Prem: Route 53 Resolver Outbound Endpoint を作成し、転送ルール（Forwarding Rule）で「example.corp」等のクエリをオンプレDNSサーバーIPへ転送する。",
                            "On-Prem -> VPC: Route 53 Resolver Inbound Endpoint を作成し、オンプレDNS側で条件付きフォワーダー（Conditional Forwarder）を設定して、VPC内のドメインクエリをInbound EndpointのIPへ飛ばす。",
                            "DNSラウンドロビンの限界:",
                            "Java等のクライアントはDNS解決結果を永続的にキャッシュする傾向があり（TTL無視）、特定のIPに負荷が偏る。",
                            "モダンな対策: Service Mesh (Envoy/App Mesh) や AWS Cloud Map を使い、DNSに依存しないAPIベースのディスカバリや、クライアントサイドロードバランシングを行う。"
                        ]
                    },
                    {
                        "section": "2. ネットワーキング(VPC, ELB, DX, DNS) - 上級編",
                        "id": "Q6",
                        "title": "Q6. Transit Gateway (TGW) の非対称ルーティングとAppliance Mode",
                        "content": [
                            "TGWを中心としたハブ＆スポーク構成で、セキュリティVPC（Inspection VPC）にファイアウォールアプライアンスを配置し、全通信を検査している。しかし、特定のAZ（アベイラビリティゾーン）間の通信だけがファイアウォールで「TCP State Violation」としてドロップされる現象が発生した。",
                            "Challenge:",
                            "TGWがパケット転送時にAZを選択するアルゴリズムと、ステートフルなファイアウォールにおいて非対称ルーティング（Asymmetric Routing）が致命的になる理由を、「行き」と「帰り」の経路差分を用いて説明せよ。",
                            "この問題を解決するためにTGWアタッチメントで有効化すべき 「Appliance Mode」 の技術的な挙動（ハッシュロジックによるフロー固定）を解説せよ。",
                            "TGWのルートテーブルにおける「Blackhole」ルートの活用例をセキュリティの観点から挙げよ。",
                            "Core Knowledge & Tech Lead's View:",
                            "非対称ルーティングの発生:",
                            "TGWはデフォルトでは、パケットの宛先等に基づき最適と判断したAZへ転送するが、往路と復路で同じAZのアタッチメント（ENI）を使う保証がない。",
                            "行き：VPC-A(AZ-a) -> TGW -> Firewall(AZ-a)",
                            "帰り：Firewall(AZ-b) -> TGW -> VPC-A(AZ-a)",
                            "ファイアウォールはAZ間でセッション情報を共有していない場合が多く（あるいは同期ラグがある）、片方向のパケットしか見ていないFWは「不正な通信」としてパケットを破棄する。",
                            "Appliance Mode:",
                            "これを有効にすると、TGWは送信元/宛先IPのハッシュ値を用いて、そのトラフィックフローを常に同じAZのアタッチメントに転送するよう固定する。これにより、行きと帰りで同じFWアプライアンスを経由することが保証される。",
                            "注意: マネジメントコンソールから設定が見えにくい場合があり、CLI/IaCでの明示的な設定が必要。",
                            "Blackholeルート:",
                            "既知の不正なCIDRや、アクセスさせたくないVPC間の通信をTGWレベルで破棄するために使用する。コストのかかるFWでのDropよりも前段で処理できる。"
                        ]
                    },
                    {
                        "section": "2. ネットワーキング(VPC, ELB, DX, DNS)",
                        "id": "Q8",
                        "title": "Q8. NACLのステートレス性",
                        "content": [
                            "状況: セキュリティグループは正しいのにSSHが繋がらない。ネットワークACL（NACL）でインバウンド22を許可している。",
                            "問: NACLが「ステートレス」であることに起因する、戻りパケットのための設定漏れは？"
                        ]
                    },
                    {
                        "section": "2. ネットワーキング(VPC, ELB, DX, DNS)",
                        "id": "Q9",
                        "title": "Q9. ELB 502 vs 504",
                        "content": [
                            "状況: ALBでエラーが発生。",
                            "ケースA: 504 Gateway Timeout",
                            "ケースB: 502 Bad Gateway",
                            "問: それぞれのエラーの原因の違いは？特に502エラーにおいて、「Webサーバー側のKeep-Alive設定」と「ALBのアイドルタイムアウト」の間にどのような不整合があると発生するか？"
                        ]
                    },
                    {
                        "section": "2. ネットワーキング(VPC, ELB, DX, DNS)",
                        "id": "Q10",
                        "title": "Q10. Transit Gatewayと非対称ルーティング",
                        "content": [
                            "状況: TGW経由でファイアウォールアプライアンスを通る通信がドロップされる。行きと帰りの経路が異なるAZを通っている。",
                            "問: ステートフルなファイアウォールがパケットを破棄するのを防ぐために、TGWアタッチメントで有効にすべき設定は？",
                            "ハイブリッド接続とDNS"
                        ]
                    },
                    {
                        "section": "2. ネットワーキング(VPC, ELB, DX, DNS)",
                        "id": "Q11",
                        "title": "Q11. Direct ConnectとMTUブラックホール",
                        "content": [
                            "状況: DX経由でPingは通るが、大きなファイルの転送やSSH接続がハングする。",
                            "問: 経路上のMTUサイズ不一致（Jumbo Frame等）と、ICMPパケットがフィルタされている場合にPath MTU Discovery (PMTUD)が失敗して起きる現象名は？"
                        ]
                    },
                    {
                        "section": "2. ネットワーキング(VPC, ELB, DX, DNS)",
                        "id": "Q12",
                        "title": "Q12. BGPフラッピング",
                        "content": [
                            "状況: VPN/DX接続が数分おきに切断・再接続を繰り返す。",
                            "問: ルーターログに見られる「Hold Timer Expired」の意味と、不安定な回線においてBGPのKeepalive/Hold Timeをどう調整すべきか？"
                        ]
                    },
                    {
                        "section": "2. ネットワーキング(VPC, ELB, DX, DNS)",
                        "id": "Q13",
                        "title": "Q13. NAT Gatewayのポート枯渇",
                        "content": [
                            "状況: プライベートサブネットから外部への接続が断続的に失敗。NAT GWのErrorPortAllocationが増加。",
                            "問: 何が枯渇しているか？S3/DynamoDBへのアクセスが原因の場合の解決策は？"
                        ]
                    },
                    {
                        "section": "2. ネットワーキング(VPC, ELB, DX, DNS)",
                        "id": "Q14",
                        "title": "Q14. Route 53 プライベートホストゾーンの解決",
                        "content": [
                            "状況: VPCピアリング先のVPCにあるプライベートホストゾーンの名前解決ができない。",
                            "問: ピアリング接続設定で有効にすべきオプションと、ホストゾーン自体に相手側VPCに対して行うべき操作は？",
                            "焦点: スケーリングの限界、整合性モデル、障害の連鎖。",
                            "RDS & Aurora"
                        ]
                    }
                ],
                "3. データベース & ストレージ (RDS, DynamoDB, S3)": [
                    {
                        "section": "3. データベース & ストレージ (RDS, DynamoDB, S3) - 上級編",
                        "id": "Q7",
                        "title": "Q7. RDS/Auroraのコネクション管理・RDS Proxy・Pinning問題",
                        "content": [
                            "PHP/LaravelアプリケーションをLambdaやFargateで大規模にスケールさせた結果、RDS (MySQL) が Too many connections でダウンした。対策として RDS Proxy を導入したが、期待したほど接続数が減らず、逆にパフォーマンスが低下したように見える。調査の結果、特定のクエリ実行時に「Pinning（ピン留め）」が発生していることが判明した。",
                            "Challenge:",
                            "max_connections パラメータがインスタンスクラスのメモリ容量に依存する理由と、メモリ枯渇が招くDBプロセスの挙動（OOM Killer等）を説明せよ。",
                            "RDS Proxyが提供する「コネクション多重化（Multiplexing）」の仕組みと、「Pinning（ピン留め）」が発生する具体的な条件（例：SETコマンド、テンポラリテーブル等）、およびそれが多重化効率を劇的に下げる理由を解説せよ。",
                            "RDS Proxyを使用することで、DBフェイルオーバー時のアプリケーションへの影響（DNS TTL待ち時間や接続エラー）をどう最小化できるか？",
                            "Core Knowledge & Tech Lead's View:",
                            "メモリと接続数:",
                            "MySQLは1接続ごとにスレッドスタックやバッファメモリを消費する。メモリ限界を超えるとスワップが発生し激重になるか、OOM Killerによりmysqldが殺される。",
                            "RDS ProxyとPinning:",
                            "通常、Proxyは大量のアプリ接続を少数のDB接続に集約（使い回し）する。",
                            "Pinning: 特定の条件（セッション変数の変更 SET @x=1、一時テーブルの作成、ユーザー定義変数の使用など）が発生すると、Proxyはそのセッションの整合性を保つため、そのアプリ接続を特定のDB接続に固定（ピン留め）してしまう。",
                            "ピン留めされた接続は他のリクエストで再利用できなくなるため、多重化の効果が消え、接続数が減らなくなる。アプリ側のコード修正で不要なSET等を排除する必要がある。",
                            "フェイルオーバー高速化:",
                            "RDS ProxyはDBの裏側でWriterの変更を検知し、アプリとの接続は維持したまま、バックエンドの接続先を新Writerへ切り替える。アプリはDNS更新や接続断を意識せず、一時的な待機だけで処理を継続できる（透過的フェイルオーバー）。"
                        ]
                    },
                    {
                        "section": "3. データベース & ストレージ (RDS, DynamoDB, S3) - 上級編",
                        "id": "Q8",
                        "title": "Q8. DynamoDBのホットパーティションと適応型キャパシティ",
                        "content": [
                            "DynamoDBを使用するソーシャルゲームで、特定の人気イベントIDにアクセスが集中し、ProvisionedThroughputExceededException が多発している。テーブル全体のキャパシティには余裕がある。AWSドキュメントには「適応型キャパシティ（Adaptive Capacity）が自動で偏りを解消する」とあるが、スロットリングが収まらない。",
                            "Challenge:",
                            "DynamoDBの1パーティションあたりの物理ハードリミット（3,000 RCU / 1,000 WCU / 10GB）を挙げ、これを超えるアクセスはAdaptive Capacityでも救えない理由を説明せよ。",
                            "Adaptive Capacityが有効になるまでのタイムラグ（反応速度）と、それが「瞬間的なスパイク」に対して無力である理由を述べよ。",
                            "ホットパーティション問題を根本解決するためのキー設計戦略（Write Sharding / Random Suffix）と、読み込み時のScatter-Gatherパターンのデメリットについて論ぜよ。",
                            "Core Knowledge & Tech Lead's View:",
                            "物理の壁:",
                            "Adaptive Capacityは、他のパーティションの余剰分をホットなパーティションに回す機能だが、単一の物理パーティションの上限（3,000 RCU / 1,000 WCU）を超えて処理させることは物理的に不可能。",
                            "特定のアイテム（単一のPK）へのアクセス集中は、必ず単一パーティションへの負荷になるため、ここがボトルネックになる。",
                            "Adaptive Capacityの限界:",
                            "以前より高速化したが、反応には数分〜程度の時間がかかる場合がある。秒単位のスパイク（Thundering Herd）には追いつかずスロットリングが発生する。",
                            "Sharding戦略:",
                            "解決策はアクセスを散らすこと。Partition Keyに _1, _2 ... _N のような乱数サフィックスをつけて書き込む（Write Sharding）。",
                            "読むときは、全サフィックス分（N回）並列クエリを投げて集約（Scatter-Gather）する必要があり、アプリの実装コストとReadコストが増加するトレードオフがある。"
                        ]
                    },
                    {
                        "section": "3. データベース & ストレージ (RDS, DynamoDB, S3) - 上級編",
                        "id": "Q9",
                        "title": "Q9. Aurora Global Databaseとレプリケーション遅延・書き込み戦略",
                        "content": [
                            "Aurora (MySQL) Global Databaseを使用し、東京（Primary）と大阪（Secondary）でDR構成を組んでいる。大阪リージョンのReaderからデータを読み込む際、東京でコミットされた直後のデータが見つからない事例がある。また、大阪リージョンから直接書き込みを行いたい要件が出てきた。",
                            "Challenge:",
                            "Auroraのストレージレイヤーにおける物理レプリケーション（Quorumモデル）と、Readerノードのページキャッシュ更新ラグによるレプリケーション遅延（数ミリ〜数十ミリ秒）のメカニズムを解説せよ。",
                            "Global DatabaseにおけるGlobal Write Forwarding（書き込み転送）機能の概要と、これを利用した際の整合性モデル（Read-after-Writeの一貫性は保証されるか？）について述べよ。",
                            "Global Databaseのフェイルオーバー（RTO）が、通常のクロスリージョンレプリケーションより劇的に速い（通常1分以内）理由を、ストレージレプリケーションの仕組みから説明せよ。",
                            "Core Knowledge & Tech Lead's View:",
                            "Auroraの遅延:",
                            "ストレージは共有されているが、Readerノードは自身のメモリ（ページキャッシュ）にデータをキャッシュしている。Writerからの「更新したよ」という無効化信号を受け取ってキャッシュを更新するまでの僅かなタイムラグが、Auroraのレプリカ遅延の正体。",
                            "Global Write Forwarding:",
                            "SecondaryリージョンのReaderで書き込みリクエストを受け取り、AWSバックボーン経由でPrimaryリージョンのWriterへ転送・実行する機能。",
                            "アプリはリージョンを意識せず書き込めるが、「書き込んだデータが即座にローカル（Secondary）のReaderで読める保証はない」（結果整合性）。書き込み完了後にレプリケーションが戻ってくるまでの遅延があるため。",
                            "高速なRTO:",
                            "Global Databaseはストレージレベルで物理ブロックを非同期転送しているため、論理レプリケーション（Binlog）よりも高速かつ低負荷。昇格（Promote）操作もストレージの役割変更だけで済むため速い。"
                        ]
                    },
                    {
                        "section": "3. データベース & ストレージ (RDS, DynamoDB, S3)",
                        "id": "Q15",
                        "title": "Q15. RDS Max Connections",
                        "content": [
                            "状況: 「Too many connections」エラー。",
                            "問: max_connectionsパラメータのデフォルト値は何に基づいているか？アプリケーション側でコネクションプーリングが必要な理由は？"
                        ]
                    },
                    {
                        "section": "3. データベース & ストレージ (RDS, DynamoDB, S3)",
                        "id": "Q16",
                        "title": "Q16. AuroraのフェイルオーバーとDNSキャッシュ",
                        "content": [
                            "状況: Auroraがフェイルオーバーしたが、アプリが古いライターへ接続を試み続けてエラーになる。",
                            "問: JavaなどのクライアントにおけるDNSキャッシュ（TTL）設定の問題点は？",
                            "DynamoDB"
                        ]
                    },
                    {
                        "section": "3. データベース & ストレージ (RDS, DynamoDB, S3)",
                        "id": "Q17",
                        "title": "Q17. ホットパーティション問題",
                        "content": [
                            "状況: 全体のキャパシティには余裕があるのに、特定キーへのアクセスでスロットリング発生。",
                            "問: パーティションキーの設計におけるカーディナリティ（偏り）の問題とは何か？また、Adaptive Capacity（適応型キャパシティ）が効くまでのタイムラグについて説明せよ。"
                        ]
                    },
                    {
                        "section": "3. データベース & ストレージ (RDS, DynamoDB, S3)",
                        "id": "Q18",
                        "title": "Q18. メタデータサービスとゴシッププロトコル",
                        "content": [
                            "状況: テーブル数やノード数が爆発的に増えた際、メタデータ管理システムが高負荷に陥る。",
                            "問: ノード間での状態共有（Membership）に使われるプロトコル名と、障害時にそれが引き起こすトラフィック増大（Storm）について説明せよ。",
                            "S3 & CloudFront"
                        ]
                    },
                    {
                        "section": "3. データベース & ストレージ (RDS, DynamoDB, S3)",
                        "id": "Q19",
                        "title": "Q19. S3の503 Slow Down",
                        "content": [
                            "状況: S3への大量のPUT/GETリクエストで503エラーが返る。",
                            "問: S3のパフォーマンスはバケット全体ではなく何単位で制限されるか？また、プレフィックスごとのリクエスト上限について答えよ。"
                        ]
                    },
                    {
                        "section": "3. データベース & ストレージ (RDS, DynamoDB, S3)",
                        "id": "Q20",
                        "title": "Q20. S3の整合性モデル（過去と現在）",
                        "content": [
                            "状況: PUT直後のGETで404になる（以前のS3）。",
                            "問: 現在のS3は強い整合性（Strong Consistency）をサポートしているが、かつての結果整合性（Eventual Consistency）時代に必要だったアプリケーション側の対策は？"
                        ]
                    },
                    {
                        "section": "3. データベース & ストレージ (RDS, DynamoDB, S3)",
                        "id": "Q21",
                        "title": "Q21. CloudFrontの古いコンテンツ（キャッシュ無効化）",
                        "content": [
                            "状況: S3上の静的ファイルを更新したが、ユーザーには古い画像が表示され続けている。",
                            "問: CloudFrontのエッジキャッシュを強制的に更新するために実行すべき操作（Invalidation）と、再発防止のための適切なキャッシュ戦略（ファイル名バージョニング等）について説明せよ。",
                            "焦点: 隠れたリソース制限、起動の失敗要因。",
                            "Lambda"
                        ]
                    }
                ],
                "4. サーバーレス & コンテナ (Lambda, ECS, EKS)": [
                    {
                        "section": "4. サーバーレス & コンテナ (Lambda, ECS, EKS) - 上級編",
                        "id": "Q10",
                        "title": "Q10. Lambda Cold Start & Concurrency Model (SnapStart)",
                        "content": [
                            "Javaで実装されたLambda関数があり、API Gateway経由で呼び出されている。不定期なアクセススパイク時に、極端なレイテンシ悪化（コールドスタート）と ThrottlingException (429) が同時に発生している。アカウントの同時実行数上限には余裕がある。",
                            "Challenge:",
                            "LambdaのBurst Concurrency（バースト同時実行数）の制限について、リージョンごとの初期バースト値（東京: 1,000など）と、それを超えた場合のスケーリング速度（毎分500インスタンス追加）の仕様を解説せよ。",
                            "Javaランタイム特有の重いコールドスタートを解消するための Lambda SnapStart の仕組み（CRaC: Checkpoint/Restore in Userspace）と、プロビジョニング済み同時実行（Provisioned Concurrency）との使い分け基準を述べよ。",
                            "Provisioned Concurrency を設定しているにもかかわらず、デプロイ直後や設定変更直後にスパイクが来るとスロットリングが発生する「初期化ラグ」の問題について触れよ。",
                            "Core Knowledge & Tech Lead's View:",
                            "Burst Limit:",
                            "アカウント上限（例: 10,000）があっても、一気に10,000まで増えるわけではない。",
                            "初期バースト（東京なら1,000）までは即座に増えるが、それ以降は 毎分500 ずつしかスケールしない。これを超える急激なスパイクは429エラーになる。",
                            "SnapStart vs Provisioned:",
                            "SnapStart: 初期化済みメモリ状態（Firecracker microVMのスナップショット）から復元して起動。無料で使える（Javaのみ）。コールドスタートを劇的に短縮するが、常時起動しているわけではない（Scale to Zero可能）。",
                            "Provisioned Concurrency: 常に指定数のWarmインスタンスを維持する（有料）。バースト制限やコールドスタートを完全に排除したい場合に必須。",
                            "初期化ラグ:",
                            "Provisioned Concurrencyの設定が完了するまで（Warm Poolが埋まるまで）数分かかる。デプロイ直後はここが弱点になりうる。"
                        ]
                    },
                    {
                        "section": "4. サーバーレス & コンテナ (Lambda, ECS, EKS) - 上級編",
                        "id": "Q11",
                        "title": "Q11. SQS + Lambda: Partial Failure & Poison Pill",
                        "content": [
                            "SQSをイベントソースとしてLambdaをトリガーしている。バッチサイズを10に設定しているが、そのうち1件のメッセージ処理だけがデータ不備でエラーになる。しかし、Lambda全体が失敗とみなされ、残りの正常な9件も含めて再処理（リトライ）が繰り返されている。",
                            "Challenge:",
                            "SQSトリガーのLambdaにおける「バッチ全体の失敗」のデフォルト挙動と、それを防ぐために実装すべき ReportBatchItemFailures（部分バッチ応答）の仕組みをコードレベルの返り値構造で説明せよ。",
                            "エラーになり続けるメッセージ（Poison Pill）が無限リトライされるのを防ぐための maxReceiveCount と DLQ (Dead Letter Queue) の正しい設定関係を述べよ。",
                            "Lambdaの非同期呼び出し（Event Invoke）におけるDLQ/Destinationsと、SQSトリガー（Sync Invoke扱い）におけるDLQの違いを明確にせよ。",
                            "Core Knowledge & Tech Lead's View:",
                            "ReportBatchItemFailures:",
                            "デフォルトでは、Lambdaが例外を投げるとバッチ全体（10件）がSQSに戻され、全て再処理される。",
                            "レスポンスに {\"batchItemFailures\": [{\"itemIdentifier\": \"message-id\"}]} を含めることで、失敗した特定のメッセージだけをSQSに残し、成功したメッセージは削除（Commit）させることができる。",
                            "DLQ設定:",
                            "SQS側でRedrive Policyを設定。maxReceiveCount（例: 3回）を超えたらDLQ用キューへ移動させる。",
                            "Invoke Modeの違い:",
                            "SQSトリガーは、Lambdaサービスがポーリングして関数を同期的に実行する。よってLambda関数のDLQ設定ではなく、SQSキューのDLQ設定が効く。",
                            "非同期呼び出し（S3通知等）の場合は、Lambda関数自体のDLQ/Destinations設定が使われる。"
                        ]
                    },
                    {
                        "section": "4. サーバーレス & コンテナ (Lambda, ECS, EKS) - 上級編",
                        "id": "Q12",
                        "title": "Q12. EKS IP Exhaustion & Fargate Profiles",
                        "content": [
                            "EKSクラスタで大量のPodを起動しようとしたところ、ノードのリソースは余っているのにIPアドレス不足でPodがPendingになった。サブネットのCIDRは/24で枯渇している。ノードを増やすこともできない。",
                            "Challenge:",
                            "VPC CNIプラグインの Warm IP / Warm ENI 戦略が、なぜIPアドレスを大量に（Pod数以上に）消費してしまうのか説明せよ。",
                            "この問題を解決するための Prefix Delegation (/28割当て) 機能の概要と、これにより1つのENIで扱えるIP数がどう変化するか述べよ。",
                            "EKS Fargate を利用する場合のIPアドレス消費モデル（PodごとのVM占有）と、EC2ノード運用と比較した際のコスト・制約（DaemonSet不可など）のトレードオフを論ぜよ。",
                            "Core Knowledge & Tech Lead's View:",
                            "Warm IP:",
                            "高速起動のため、VPC CNIはENIに付与可能なIPをあらかじめ確保（プール）しておく。デフォルトではENIの限界までIPを確保しようとするため、サブネットIPを食いつぶす。",
                            "Prefix Delegation:",
                            "ENIに個別のIPではなく、/28 プレフィックス（16個のIPブロック） を割り当てる。",
                            "1回のAPIコールで16個分のIP枠を確保でき、IP枯渇問題とAPIスロットリング問題を同時に緩和できる。",
                            "Fargateの特性:",
                            "Fargate Podは1つ1つが個別のMicroVMで動作し、個別のENIを持つ。つまりPod数 = IP消費数となる。",
                            "DaemonSetが使えないため、ログ収集や監視のエージェントをサイドカーとして全Podに入れる必要があり、リソース効率が悪化する場合がある。"
                        ]
                    },
                    {
                        "section": "4. サーバーレス & コンテナ (Lambda, ECS, EKS)",
                        "id": "Q22",
                        "title": "Q22. 同時実行数とスロットリング",
                        "content": [
                            "状況: Lambdaが429エラー。アカウント上限（1000等）には達していない。",
                            "問: バースト同時実行数（Burst Concurrency）の制限（リージョンごとの初期バースト値とスケーリング速度）について説明せよ。"
                        ]
                    },
                    {
                        "section": "4. サーバーレス & コンテナ (Lambda, ECS, EKS)",
                        "id": "Q23",
                        "title": "Q23. VPC LambdaとENI（Hyperplaneの理解）",
                        "content": [
                            "状況: VPC Lambdaの接続数が増えるとIPアドレスが枯渇する懸念。",
                            "問: 以前の仕様と異なり、現在のHyperplane ENIはどのようにENIを共有するか？それでもIP枯渇が起きるケースは？"
                        ]
                    },
                    {
                        "section": "4. サーバーレス & コンテナ (Lambda, ECS, EKS)",
                        "id": "Q24",
                        "title": "Q24. 非同期呼び出しとリトライストーム",
                        "content": [
                            "状況: S3トリガーのLambdaがエラーになり続け、ログが爆発的に増えている。",
                            "問: 非同期呼び出しの自動リトライ仕様（2回+キュー滞留）と、DLQ（デッドレターキュー）を設定していない場合のリスクは？",
                            "コンテナ (ECS/EKS)"
                        ]
                    },
                    {
                        "section": "4. サーバーレス & コンテナ (Lambda, ECS, EKS)",
                        "id": "Q25",
                        "title": "Q25. EKS IP枯渇とCNIプラグイン",
                        "content": [
                            "状況: EKSでPodがPendingのまま。ノードのリソースは余っている。",
                            "問: AWS VPC CNIプラグインのデフォルト挙動（Warm IP）が、どのようにサブネットのIPアドレスを大量消費するか？"
                        ]
                    },
                    {
                        "section": "4. サーバーレス & コンテナ (Lambda, ECS, EKS)",
                        "id": "Q26",
                        "title": "Q26. ECSタスク起動失敗とイメージプル",
                        "content": [
                            "状況: FargateタスクがPENDING -> STOPPEDを繰り返す。",
                            "問: プライベートサブネットでNAT GWがない場合、ECRからイメージをプルできるか？必要なVPCエンドポイントは？"
                        ]
                    },
                    {
                        "section": "4. サーバーレス & コンテナ (Lambda, ECS, EKS)",
                        "id": "Q27",
                        "title": "Q27. CrashLoopBackOffの調査",
                        "content": [
                            "状況: Podが再起動を繰り返す。現在のログを見ても何も出ていない。",
                            "問: 直前のクラッシュ時のログを見るためのkubectlオプションは？",
                            "焦点: 権限不足の特定、IAMロールの仕様。"
                        ]
                    }
                ],
                "5. IAM & セキュリティのトラブルシューティング": [
                    {
                        "section": "5. IAM & セキュリティのトラブルシューティング - 上級編",
                        "id": "Q13",
                        "title": "Q13. Circuit Breaker & Bulkhead Patterns",
                        "content": [
                            "外部の決済APIが遅延し始め、呼び出し元のECSサービスの全スレッドが待機状態（Blocked）になり、ヘルスチェックすら応答できずにシステムダウン（Cascading Failure）した。再起動しても即座にまた詰まる。",
                            "Challenge:",
                            "Circuit Breaker パターンの3状態（Closed、 Open, Half-Open）の遷移ロジックに加え、Fail Fast（即時失敗）がシステム全体の生存になぜ不可欠なのか解説せよ。",
                            "サーキットブレーカーだけでは防げない「リソース枯渇」に対処するための Bulkhead（隔壁）パターン の実装方法（スレッドプール分離やセマフォ分離）を述べよ。",
                            "AWS App MeshやEnvoyプロキシの Outlier Detection（外れ値検知） 機能を用いて、インフラ層でこれを自動化する方法について触れよ。",
                            "Core Knowledge & Tech Lead's View:",
                            "Fail Fast:",
                            "ダメな時は待たずに即エラーを返すこと。タイムアウトまで待つ（ブロッキングする）時間が、スレッドやメモリを占有し、他の健全な処理まで道連れにする。",
                            "Bulkhead:",
                            "船の隔壁のようにリソースを区切る。決済API用のスレッドプールと、ヘルスチェック/Topページ用のスレッドプールを分ける。これにより決済APIが死んでもTopページは生き残る。",
                            "Outlier Detection:",
                            "Envoyなどのプロキシが、連続して5xxを返すアップストリームホストを一時的に切り離す（Ejection）機能。アプリコードを変更せずにサーキットブレーカー相当の動きを実現できる。"
                        ]
                    },
                    {
                        "section": "5. IAM & セキュリティのトラブルシューティング - 上級編",
                        "id": "Q14",
                        "title": "Q14. Static Stability & Route 53 ARC",
                        "content": [
                            "AWSのリージョン規模の障害（Control Plane障害）が発生し、EC2の新規起動やAuto Scaling、Route 53のAPI変更ができない状況に陥った。しかし、経営陣は「稼働中のリソースだけでサービスを継続せよ」と要求している。",
                            "Challenge:",
                            "Static Stability（静的安定性） の概念を定義し、障害発生時に「コントロールプレーン（設定変更）」に依存しないアーキテクチャがいかにして可用性を高めるか説明せよ。",
                            "Route 53 Application Recovery Controller (ARC) の機能（ゾーンシフトやルーティングコントロール）が、従来のヘルスチェックベースのDNSフェイルオーバーと比べて、なぜより確実な復旧手段となり得るのか論ぜよ。",
                            "静的安定性を実現するためのコスト（Over-provisioning）は「保険料」であるが、リザーブドインスタンスやSavings Plans、Spot Instancesをどう組み合わせればコストを最適化しつつ冗長性を維持できるか？",
                            "Core Knowledge & Tech Lead's View:",
                            "Static Stability:",
                            "「障害が起きてからスケールする（Reactive）」のではなく、「障害が起きてもそのままで耐えられる」状態。",
                            "例: 3AZ構成で1AZがダウンしても、残りの2AZだけでトラフィックを捌けるよう、平時から50%余分に（合計150%の）リソースを稼働させておく。",
                            "障害時はAPI（RunInstances）自体が失敗する可能性が高いため、既存のリソース（Data Plane）だけで戦うのが最強。",
                            "Route 53 ARC:",
                            "ヘルスチェックは「偽陽性（False Positive）」や「フラッピング」のリスクがある。",
                            "ARCは、人間または自動システムが明示的に「スイッチを切り替える」ことで、DNSの重み付けを安全かつ確実に変更する仕組み。コントロールプレーンの依存を排除した特殊なデータプレーンで動作する。"
                        ]
                    },
                    {
                        "section": "5. IAM & セキュリティのトラブルシューティング - 上級編",
                        "id": "Q15",
                        "title": "Q15. Thundering Herd & Jitter / Idempotency",
                        "content": [
                            "大規模障害から復旧した瞬間、数百万のクライアントが一斉に再接続（Reconnect）を試み、データベースとロードバランサーが即死した（Thundering Herd問題）。また、リトライによって二重決済が発生している。",
                            "Challenge:",
                            "クライアント側のリトライロジックにおける Exponential Backoff だけでは不十分で、Jitter（ゆらぎ） を加えることが数学的に必須である理由を説明せよ。",
                            "分散システムにおける 冪等性（Idempotency） の担保戦略として、APIリクエストに含めるべき Idempotency Key の役割と、サーバー側（DynamoDBやRedis）での実装パターン（TTL付きロック等）を設計せよ。",
                            "サーバー側での防御策としての Load Shedding（負荷制限・切り捨て） の重要性と、AWS WAFやAPI Gatewayでの実装例を挙げよ。",
                            "Core Knowledge & Tech Lead's View:",
                            "Jitter:",
                            "指数バックオフ（1秒, 2秒, 4秒...）だけだと、全員が同じタイミングで待って同じタイミングで再試行するため、負荷の「波」が消えない。",
                            "ランダムな時間を加える（Jitter）ことで、アクセスを時間の軸で平準化・分散させる。",
                            "Idempotency Key:",
                            "クライアントがリクエスト時に一意なID（UUID等）を付与。",
                            "サーバーは「このIDは処理済みか？」をKVS等で確認。処理済みなら実際の処理をスキップして、前回と同じ成功レスポンスを返す。",
                            "これにより、タイムアウト時のリトライによる二重処理（二重課金）を安全に防げる。"
                        ]
                    },
                    {
                        "section": "5. IAM & セキュリティのトラブルシューティング - 上級編",
                        "id": "Q16",
                        "title": "Q16. Blast Radius & Cellular Architecture",
                        "content": [
                            "ある一人のヘビーユーザー（または設定ミスのテナント）が共有リソースを食いつぶし、全ユーザーに影響が出る大規模障害が発生した。これを防ぐために Cell-based Architecture（セルラーアーキテクチャ） への移行を検討している。",
                            "Challenge:",
                            "Cellular Architecture の基本概念と、シャーディング（DB分割）との決定的な違い（スタック全体の垂直分割）を説明せよ。",
                            "セルラー構成における Routing Layer（薄いルーティング層） の設計課題と、Route 53やCloudFront Functionsを用いてユーザーを正しいセルに導く方法を提案せよ。",
                            "セルラーアーキテクチャが Blast Radius（爆発半径） を最小化するメカニズムと、デプロイメントの安全性（1セルずつデプロイ）への寄与について論ぜよ。",
                            "Core Knowledge & Tech Lead's View:",
                            "Cellular Architecture:",
                            "システム全体（LB、 Web、 App, DB、 Queue）を独立した「セル」という単位に分割して並列化する。",
                            "シャーディングはDBだけだが、セルは全スタックを隔離する。あるセルが死んでも、影響はそのセル内のユーザー（例: 全体の5%）に限定される。",
                            "Routing:",
                            "「誰がどのセルにいるか」を知るためのマッピングが必要。",
                            "最も堅牢なのは、計算不要な静的なパーティション（例：ユーザーIDのハッシュ値）を使い、Route 53やCloudFront Edgeで振り分ける方法。ルーティング層自体がSPOFにならないように極限までシンプルにする（Simple is reliable）。"
                        ]
                    },
                    {
                        "section": "5. IAM & セキュリティのトラブルシューティング",
                        "id": "Q28",
                        "title": "Q28. 権限不足のデバッグ",
                        "content": [
                            "状況: アプリケーションがS3へのアクセスでAccess Deniedになる。",
                            "問: CloudTrailで該当のAPIコールを検索し、どのポリシー（アイデンティティベース、リソースベース、SCP）が拒否しているか特定する手順は？"
                        ]
                    },
                    {
                        "section": "5. IAM & セキュリティのトラブルシューティング",
                        "id": "Q29",
                        "title": "Q29. iam:PassRole",
                        "content": [
                            "状況: EC2インスタンスを起動する権限はあるが、インスタンスにIAMロールを割り当てようとするとエラーになる。",
                            "問: ロールをAWSサービスに渡すためのiam:PassRole権限の必要性について説明せよ。",
                            "焦点: 過去のPost-Mortemから学ぶ、カスケード障害と静的安定性。",
                            "過去の大規模障害から学ぶ"
                        ]
                    }
                ],
                "6. 大規模障害ケーススタディ & レジリエンス": [
                    {
                        "section": "6. 大規模障害ケーススタディ & レジリエンス",
                        "id": "Q17",
                        "title": "Q17. S3 Strong Consistency & Data Lake Performance",
                        "content": [
                            "S3をデータレイクとして使用し、Athenaで分析している。以前は「書き込み直後の読み込み」でデータが見えない問題（結果整合性）があったが、現在は解消されているはずだ。しかし、大量の小さなファイルをPUTした直後にLIST操作を行うとパフォーマンスが出ない。",
                            "Challenge:",
                            "現在のS3が提供する Strong Consistency（強い整合性） の仕様（PUT/DELETE後のREAD/LIST）について、正確に述べよ。",
                            "S3のパフォーマンスにおける Prefix（プレフィックス） の重要性と、かつて必要だった「ハッシュ化プレフィックス」が現在では不要になった理由、および現在のスケーリング仕様（1プレフィックスあたりのTPS: 3,500 PUT / 5,500 GET）を解説せよ。",
                            "大量の小ファイル問題（Small File Problem）がAthena/Sparkのパフォーマンスに与える悪影響と、これを解決するための S3 DistCp やETL処理でのファイル結合（Compaction）の重要性を説け。",
                            "Core Knowledge & Tech Lead's View:",
                            "Strong Consistency: 2020年末より、S3は全てのPUT/DELETE操作に対して強い整合性を持つようになった。書き込み直後のGETやLISTは常に最新の結果を返す。",
                            "Partitioning: S3は自動的にプレフィックスに基づいてパーティションを分割・スケールさせる。現在はハッシュ化不要で、順次プレフィックス（日付等）でも自動でスケールするが、急激なスパイクには 503 Slow Down が出る場合がある。",
                            "Small Files: S3/Athenaは数KBのファイルを数百万個読むのが苦手（APIコール数とレイテンシのオーバーヘッド）。MB〜GB単位にまとめる（Compaction）のが鉄則。"
                        ]
                    },
                    {
                        "section": "6. 大規模障害ケーススタディ & レジリエンス",
                        "id": "Q18",
                        "title": "Q18. Gateway Load Balancer (GWLB) & Inspection",
                        "content": [
                            "セキュリティ要件により、VPCに出入りする全トラフィックをサードパーティ製のファイアウォールアプライアンス（Palo Alto、 FortiGate等）で検査したい。従来はTGWやVPN接続が必要だったが、構成が複雑でボトルネックになりやすい。",
                            "Challenge:",
                            "Gateway Load Balancer (GWLB) が提供する「Bump-in-the-wire（透過的検査）」アーキテクチャの仕組みを、GENEVEプロトコルとルートテーブルのターゲット指定（Gateway Load Balancer Endpoint: GWLBE）を用いて解説せよ。",
                            "GWLBを使用することで、アプライアンスのオートスケーリングやヘルスチェックが容易になる理由を、従来のEC2ベースのFW構成と比較して述べよ。",
                            "Ingress Routing（インターネットからの流入）において、Internet Gateway (IGW) のルートテーブルで Ingress Routing（Edge Association） を設定し、トラフィックをGWLBEに強制的に引き込む手法を説明せよ。",
                            "Core Knowledge & Tech Lead's View:",
                            "GWLB: L3（ネットワーク層）で動作し、パケットをカプセル化（GENEVE）して裏側のFWフリートに投げる。FWはパケットを検査してそのまま返す。",
                            "透過性: アプリ側や通信相手からは、間にGWLB/FWがいることは見えない（IPが変わらない）。NATも不要。",
                            "Ingress Routing: IGWに関連付けたルートテーブルで、Dest: Subnet-CIDR -> Target: GWLBE と書くことで、外から入ってきたパケットを強制的に検査装置へねじ曲げることができる。"
                        ]
                    },
                    {
                        "section": "6. 大規模障害ケーススタディ & レジリエンス",
                        "id": "Q19",
                        "title": "Q19. Container Insights & Observability",
                        "content": [
                            "EKS上でマイクロサービスを運用しているが、PodがOOMKilled（メモリ不足で強制終了）されていることに気づくのが遅れた。CloudWatchの標準メトリクスではノード全体のCPU/メモリしか見えず、Pod単位の特定が困難である。",
                            "Challenge:",
                            "CloudWatch Container Insights を有効化することで収集されるメトリクスの粒度（Cluster、 Node、 Pod、 Service）と、その背後で動くエージェント（CloudWatch Agent / Fluent Bit）の役割を説明せよ。",
                            "OOMKilled のようなイベントを即座に検知するために、Container Insightsのメトリクス（pod_memory_utilization等）やログパターン監視（Reason: OOMKilled）をどう設定すべきか。",
                            "プロメテウス（Amazon Managed Service for Prometheus）とGrafanaを用いたOSSベースの監視スタックと、Container Insightsの使い分け（コスト、手軽さ、詳細度）についてTech Leadとしての推奨を述べよ。",
                            "Core Knowledge & Tech Lead's View:",
                            "Container Insights: Fluent Bit等がコンテナランタイムやkubeletから詳細情報を吸い上げ、構造化データとしてCloudWatchに送る。Pod単位のリソース使用率が見えるようになる。",
                            "OOM検知: メモリ使用率監視だけでは不十分（スパイクで死ぬため）。K8sイベントログやアプリログで OOMKilled 文字列を監視し、アラートを飛ばすのが確実。",
                            "Prometheus vs CW: 大規模クラスタで全PodのメトリクスをCWに送るとコストが爆発する（Custom Metrics課金）。大規模環境ではPrometheusの方が安価で柔軟な場合が多い。小規模ならCW Container Insightsが手軽。"
                        ]
                    },
                    {
                        "section": "6. 大規模障害ケーススタディ & レジリエンス",
                        "id": "Q20",
                        "title": "Q20. Security Hub & GuardDuty: Continuous Compliance",
                        "content": [
                            "複数のAWSアカウントを持つ組織で、セキュリティ基準（PCI DSSやCIS Benchmark）の遵守状況を可視化したい。また、アクセスキーの漏洩やコインマイニングなどの脅威をリアルタイムで検知したい。",
                            "Challenge:",
                            "Amazon GuardDuty が検知できる脅威の種類（VPC Flow Logs、 CloudTrail、 DNS Logsの分析）と、これがエージェントレスで動作するメリットを述べよ。",
                            "AWS Security Hub が提供する「一元管理」と「自動修復（Automated Remediation）」の機能を、EventBridgeとLambdaを組み合わせたアーキテクチャで説明せよ（例：意図しないSG開放を検知して即座に閉じる）。",
                            "組織全体（AWS Organizations）でこれらのセキュリティサービスを有効化する際のベストプラクティス（委任管理者: Delegated Administratorの設定）について触れよ。",
                            "Core Knowledge & Tech Lead's View:",
                            "GuardDuty: ログを機械学習で分析し、異常な通信（C&Cサーバーへの接続）やIAMの異常なAPIコールを検知。エージェント不要なので全アカウントで即ONにすべき（必須）。",
                            "Security Hub: 各種セキュリティサービス（GuardDuty、 Inspector, Macie）のアラートを集約し、CISベンチマーク等のスコアを表示する。",
                            "自動修復: Security Hubの検知イベント -> EventBridge -> Lambda で、「SGの22番ポート開放"
                        ]
                    },
                    {
                        "section": "6. 大規模障害ケーススタディ & レジリエンス (SRE/Principal)",
                        "id": "Q30",
                        "title": "Q30. 2020年 Kinesis障害とカスケード",
                        "content": [
                            "状況: Kinesisの障害により、CognitoやCloudWatch、Auto Scalingまでもが連鎖的に機能不全に陥った。",
                            "問: なぜKinesisの障害が他のサービスに波及したのか？「フリート全体の最大スレッド数超過」と「循環依存」の観点から説明せよ。"
                        ]
                    },
                    {
                        "section": "6. 大規模障害ケーススタディ & レジリエンス (SRE/Principal)",
                        "id": "Q31",
                        "title": "Q31. 2017年 S3障害と爆発半径",
                        "content": [
                            "状況: コマンド入力ミスにより、想定以上のS3サブシステムサーバーが削除され、リージョン障害に発展。",
                            "問: この教訓から生まれた、運用ツールにおける「爆発半径（Blast Radius）の最小化」や「セルラーアーキテクチャ」とは？"
                        ]
                    },
                    {
                        "section": "6. 大規模障害ケーススタディ & レジリエンス (SRE/Principal)",
                        "id": "Q32",
                        "title": "Q32. 2021年 US-EAST-1障害と内部DNS",
                        "content": [
                            "状況: 内部ネットワークの輻輳により、AWS内部DNSの解決が失敗し、APIエラーが多発。",
                            "問: サービス間通信においてDNS解決に依存することのリスクと、データプレーンの静的安定性（Static Stability）の重要性は？",
                            "運用戦略"
                        ]
                    },
                    {
                        "section": "6. 大規模障害ケーススタディ & レジリエンス (SRE/Principal)",
                        "id": "Q33",
                        "title": "Q33. Thundering Herd（再開の波）対策",
                        "content": [
                            "状況: 障害復旧直後、待機していたリクエストが一斉に殺到し、DBが再度ダウン（ブラウンアウト）。",
                            "問: クライアント側のリトライロジックに入れるべきExponential BackoffとJitter（ゆらぎ）の効果は？"
                        ]
                    },
                    {
                        "section": "6. 大規模障害ケーススタディ & レジリエンス (SRE/Principal)",
                        "id": "Q34",
                        "title": "Q34. サーキットブレーカー",
                        "content": [
                            "状況: 依存する外部APIが遅延し、自システムの全スレッドが待機状態で埋め尽くされた。",
                            "問: 障害のある依存先を即座に切り離し、即時エラーを返すことで自システムを守るデザインパターンは？",
                            "焦点: 見落としがちな仕様、泥臭い運用回避策。"
                        ]
                    }
                ],
                "7. その他・運用Tips (Cost, Ops)": [
                    {
                        "section": "7. その他・運用Tips (Cost, Ops)",
                        "id": "Q35",
                        "title": "Q35. Windows RDPパスワード取得不可",
                        "content": [
                            "状況: Windowsインスタンス起動後、「パスワードはまだ使用できません」と表示され続ける。",
                            "問: インスタンス内部で動いている、パスワード生成に必要な初期化サービスの名前は？"
                        ]
                    },
                    {
                        "section": "7. その他・運用Tips (Cost, Ops)",
                        "id": "Q36",
                        "title": "Q36. サポートケース起票の鉄則",
                        "content": [
                            "状況: 技術サポートに調査を依頼するが、解決が遅い。",
                            "問: 初回の問い合わせで必ず含めるべき、調査時間を短縮するための3つの具体的情報は？"
                        ]
                    },
                    {
                        "section": "7. その他・運用Tips (Cost, Ops)",
                        "id": "Q37",
                        "title": "Q37. 終了保護の罠",
                        "content": [
                            "状況: 終了保護（Termination Protection）を有効にしたインスタンスが、Auto Scalingのスケールイン時に削除されてしまった。",
                            "問: なぜか？ASG側で設定すべき項目は？"
                        ]
                    },
                    {
                        "section": "7. その他・運用Tips (Cost, Ops)",
                        "id": "Q38",
                        "title": "Q38. コスト急増の犯人探し",
                        "content": [
                            "状況: データ転送量が急増し高額請求が来た。",
                            "問: VPCフローログ以外に、S3へのアクセス（APIコール数や転送量）を詳細に分析するために有効にする機能は？"
                        ]
                    }
                ]
            };

            const pmQuizData = {
                "1. 要件・意思決定": [
                    {
                        "section": "1. 要件・意思決定",
                        "id": "Q1",
                        "title": "Q1. 要求が曖昧なまま始まりそうなとき",
                        "content": [
                            "新規プロジェクトのキックオフ前だが、要件が「ユーザーにとって便利な機能」というレベルに留まっている。期限は決まっている。この状態でPMは何を決め、何を決めずに進めるか。",
                            "",
                            "意図:",
                            "要件が曖昧＝止める、ではなく曖昧なままでも決められる粒度を切り出せるか。"
                        ]
                    },
                    {
                        "section": "1. 要件・意思決定",
                        "id": "Q2",
                        "title": "Q2. ステークホルダーの意見が割れたとき",
                        "content": [
                            "事業側はスピード重視、技術側は品質重視。両者の主張はどちらも合理的で、決定を先延ばしにすると影響が出る。PMは何を根拠に意思決定すべきか。",
                            "",
                            "意図:",
                            "調整役ではなく、決断役として立てるか。"
                        ]
                    },
                    {
                        "section": "1. 要件・意思決定",
                        "id": "Q3",
                        "title": "Q3. スコープ追加の要求",
                        "content": [
                            "開発後半になって、「ついでにこれも入れたい」という要望が出た。工数は小さく見えるが、影響範囲は不明。PMとしてどう判断するか。",
                            "",
                            "意図:",
                            "工数ではなく不確実性を見ているか。"
                        ]
                    },
                    {
                        "section": "1. 要件・意思決定",
                        "id": "Q11",
                        "title": "Q11. 判断を急がされる状況",
                        "content": [
                            "市場要因により、当初想定より1か月前倒しでのリリースを求められた。品質・スコープ・体制のいずれも余裕はない。PMとして「即断すること」と「即断しないこと」をどう分けるか。",
                            "",
                            "意図:",
                            "スピード要求下での判断の分離能力。"
                        ]
                    },
                    {
                        "section": "1. 要件・意思決定",
                        "id": "Q14",
                        "title": "Q14. 判断材料が足りないまま決める必要があるとき",
                        "content": [
                            "重要な意思決定だが、情報が揃うまで待つと機会を逃す。どの条件が揃った時点で決断するか。",
                            "",
                            "意図:",
                            "完全情報を前提にしない意思決定基準。"
                        ]
                    }
                ],
                "2. チーム・人": [
                    {
                        "section": "2. チーム・人",
                        "id": "Q5",
                        "title": "Q5. 成果が出ていないメンバーへの対応",
                        "content": [
                            "特定のメンバーのアウトプットが安定せず、チーム全体の足を引っ張り始めている。技術力・意欲・環境、原因は不明。PMとして最初に取る行動は何か。",
                            "",
                            "意図:",
                            "人を評価する前に、状況を設計し直せるか。"
                        ]
                    }
                ],
                "3. プロセス・計画": [
                    {
                        "section": "3. プロセス・計画",
                        "id": "Q4",
                        "title": "Q4. 失敗が見え始めたとき",
                        "content": [
                            "進捗は表面上問題ないが、チームの雰囲気やレビュー内容から、「このままだと後で崩れる」という兆候を感じている。PMはどの時点で介入するべきか。",
                            "",
                            "意図:",
                            "数値に出る前の違和感をどう扱うか。"
                        ]
                    },
                    {
                        "section": "3. プロセス・計画",
                        "id": "Q12",
                        "title": "Q12. 成果が測れない施策",
                        "content": [
                            "経営判断で「効果は数値化しづらいが重要」とされる施策を実施することになった。PMとして、何をもって成功・失敗を判断するか。",
                            "",
                            "意図:",
                            "KPI不在時の評価軸設計。"
                        ]
                    },
                    {
                        "section": "3. プロセス・計画",
                        "id": "Q13",
                        "title": "Q13. 計画が機能しなくなったとき",
                        "content": [
                            "計画は存在するが、現場が誰も参照していない状態になっている。計画を作り直すべきか、運用を変えるべきか。どう判断するか。",
                            "",
                            "意図:",
                            "計画を成果物ではなく道具として扱えるか。"
                        ]
                    }
                ],
                "4. 評価・指標": [
                    {
                        "section": "4. 評価・指標",
                        "id": "Q6",
                        "title": "Q6. 成功しているが違和感があるプロジェクト",
                        "content": [
                            "売上・評価ともに良好だが、チームが疲弊しており、このやり方が続くとは思えない。PMとして、この状態をどう扱うか。",
                            "",
                            "意図:",
                            "短期成功を疑えるか。"
                        ]
                    },
                    {
                        "section": "4. 評価・指標",
                        "id": "Q7",
                        "title": "Q7. 数値目標が逆効果になったとき",
                        "content": [
                            "KPIを設定した結果、チームが数字を達成することだけに最適化し始めた。品質や協力が下がっている。PMはKPIをどう扱うべきか。",
                            "",
                            "意図:",
                            "指標を神聖化しない判断ができるか。"
                        ]
                    },
                    {
                        "section": "4. 評価・指標",
                        "id": "Q10",
                        "title": "Q10. PMとしての成果の定義",
                        "content": [
                            "プロジェクトが終了した。機能はリリースされ、一定の成果も出た。PMとして、このプロジェクトの成功／失敗をどう定義するか。",
                            "",
                            "意図:",
                            "成果をアウトプット以外で語れるか。"
                        ]
                    }
                ],
                "5. 技術・判断": [
                    {
                        "section": "5. 技術・判断",
                        "id": "Q8",
                        "title": "Q8. 技術的判断に踏み込むべきか",
                        "content": [
                            "技術選定について、開発チーム内で意見が割れている。PMは技術の専門家ではない。どこまで踏み込み、どこから任せるべきか。",
                            "",
                            "意図:",
                            "分からないことを理由に逃げないか。"
                        ]
                    },
                    {
                        "section": "5. 技術・判断",
                        "id": "Q9",
                        "title": "Q9. プロジェクトを止める判断",
                        "content": [
                            "進行中のプロジェクトが、コスト・品質・市場状況の観点から見て成功確率が低下している。「止める」という判断はいつ成立するか。",
                            "",
                            "意図:",
                            "継続バイアスから自由か。"
                        ]
                    }
                ],
                "6. 権限・委譲": [
                    {
                        "section": "6. 権限・委譲",
                        "id": "Q15",
                        "title": "Q15. 利害が対立しないが納得度が低い",
                        "content": [
                            "全員が「反対ではない」が、誰も納得していない決定がある。PMとして、この状態をどう扱うか。",
                            "",
                            "意図:",
                            "表面合意と内的納得の違いを見抜けるか。"
                        ]
                    },
                    {
                        "section": "6. 権限・委譲",
                        "id": "Q16",
                        "title": "Q16. 自分の判断ミスに気づいたとき",
                        "content": [
                            "過去のPM判断が、現在の問題の原因になっていると分かった。この事実をどう扱い、どう修正するか。",
                            "",
                            "意図:",
                            "自己正当化をせず判断を更新できるか。"
                        ]
                    },
                    {
                        "section": "6. 権限・委譲",
                        "id": "Q17",
                        "title": "Q17. 判断を委譲するかどうか",
                        "content": [
                            "PMが判断すべき領域と、チームに委ねるべき領域の境界はどこか。その境界は状況によってどう変わるか。",
                            "",
                            "意図:",
                            "権限設計と責任設計の理解。"
                        ]
                    }
                ],
                "7. 学習・適応": [
                    {
                        "section": "7. 学習・適応",
                        "id": "Q18",
                        "title": "Q18. 成功パターンの再利用",
                        "content": [
                            "過去に成功した進め方を、別プロジェクトに適用しようとしている。どの条件が一致していれば再利用し、どこが違えば捨てるか。",
                            "",
                            "意図:",
                            "成功体験を抽象化しすぎない力。"
                        ]
                    },
                    {
                        "section": "7. 学習・適応",
                        "id": "Q19",
                        "title": "Q19. 優先順位が頻繁に変わる状況",
                        "content": [
                            "外部要因により優先順位が短期間で何度も変わる。PMとして、何を固定し、何を流動的に扱うか。",
                            "",
                            "意図:",
                            "不安定な状況での軸の持ち方。"
                        ]
                    },
                    {
                        "section": "7. 学習・適応",
                        "id": "Q20",
                        "title": "Q20. PMが不要になったと感じる瞬間",
                        "content": [
                            "プロジェクトが自走し始め、PMの介在が減っている。この状態を成功と見るか、リスクと見るか。",
                            "",
                            "意図:",
                            "PMの価値を自己中心的に定義していないか。"
                        ]
                    }
                ]
            };

            const qualityQuizData = {
                "1. 品質の兆候・評価": [
                    {
                        "section": "1. 品質の兆候・評価",
                        "id": "Q1",
                        "title": "Q1. 品質が落ち始めた兆候",
                        "content": [
                            "あるプロジェクトで、リリース頻度は維持されているが軽微な不具合報告が徐々に増えている。この時点で、PMとして最初に確認すべき情報は何か。また、すぐに対策を打たない判断は成立するか。",
                            "",
                            "意図:",
                            "品質を「数値」ではなく変化の傾向で捉えられるか。"
                        ]
                    },
                    {
                        "section": "1. 品質の兆候・評価",
                        "id": "Q4",
                        "title": "Q4. 品質指標の選び方",
                        "content": [
                            "品質を可視化するため、KPIを設定することになった。不具合件数・テストカバレッジ・レビュー指摘数などが候補にある。どの指標を採用し、どれを採用しないか。その理由は。",
                            "",
                            "意図:",
                            "測れるもの＝見るべきものと誤解していないか。"
                        ]
                    },
                    {
                        "section": "1. 品質の兆候・評価",
                        "id": "Q10",
                        "title": "Q10. 「十分な品質」の定義",
                        "content": [
                            "プロジェクト終盤で「品質は十分か？」という問いが出た。この問いに対して、PMはどのように答えるべきか。また、「十分」という言葉をどう扱うか。",
                            "",
                            "意図:",
                            "品質を絶対値ではなく合意形成として扱えるか。"
                        ]
                    },
                    {
                        "section": "1. 品質の兆候・評価",
                        "id": "Q20",
                        "title": "Q20. 品質が良すぎると感じたとき",
                        "content": [
                            "品質指標は非常に良好だが、それに見合う価値が出ていないと感じる。この状態をどう評価するか。",
                            "",
                            "意図:",
                            "品質を目的化していないかの確認。"
                        ]
                    }
                ],
                "2. テスト・検証": [
                    {
                        "section": "2. テスト・検証",
                        "id": "Q2",
                        "title": "Q2. テスト工数削減の提案",
                        "content": [
                            "スケジュール遅延を理由に、開発側から「今回はテストケースを半分にしたい」という提案が出た。この提案を判断する際、PMは何を条件に可否を決めるべきか。",
                            "",
                            "意図:",
                            "品質を「削る／守る」の二択で考えていないか。"
                        ]
                    },
                    {
                        "section": "2. テスト・検証",
                        "id": "Q12",
                        "title": "Q12. テストが信頼されていない",
                        "content": [
                            "テストは実施されているが、「どうせ抜ける」という空気がある。品質を上げるために、まず何を変えるか。",
                            "",
                            "意図:",
                            "工数ではなく信頼の問題と認識できるか。"
                        ]
                    }
                ],
                "3. 責任・原因分析": [
                    {
                        "section": "3. 責任・原因分析",
                        "id": "Q3",
                        "title": "Q3. 品質問題の責任所在",
                        "content": [
                            "リリース後に不具合が発生し、開発チーム内で責任の押し付け合いが起きている。PMとして、原因分析と再発防止をどう切り分けるか。",
                            "",
                            "意図:",
                            "犯人探しと品質改善を分離できるか。"
                        ]
                    },
                    {
                        "section": "3. 責任・原因分析",
                        "id": "Q9",
                        "title": "Q9. 外部要因による品質低下",
                        "content": [
                            "外部APIや他チームの成果物が不安定で、自チームの品質が引きずられている。PMとして、どこまでを「自分たちの品質」として扱うか。",
                            "",
                            "意図:",
                            "品質の責任境界を定義できるか。"
                        ]
                    },
                    {
                        "section": "3. 責任・原因分析",
                        "id": "Q19",
                        "title": "Q19. 外部要因による品質低下（制御不能領域）",
                        "content": [
                            "外部APIや他チームの影響で品質問題が起きている。自チームで制御できない要因をどう扱うか。",
                            "",
                            "意図:",
                            "コントロール不能領域の設計的扱い。"
                        ]
                    }
                ],
                "4. 技術的負債": [
                    {
                        "section": "4. 技術的負債",
                        "id": "Q5",
                        "title": "Q5. 技術的負債の扱い",
                        "content": [
                            "明確な技術的負債が存在するが、短期的なビジネス要求が強く、返済の時間が取れない。PMとして、どのタイミングで「返す」と判断するか。",
                            "",
                            "意図:",
                            "技術的負債を感情論ではなく投資判断で扱えるか。"
                        ]
                    }
                ],
                "5. プロセス": [
                    {
                        "section": "5. プロセス",
                        "id": "Q6",
                        "title": "Q6. プロセスが形骸化したとき",
                        "content": [
                            "レビュー・朝会・ふりかえりは実施されているが、形だけになり、改善につながっていない。プロセスを増やさずに改善するなら、何を変えるか。",
                            "",
                            "意図:",
                            "プロセスを「足す人」か「意味を問い直す人」か。"
                        ]
                    },
                    {
                        "section": "5. プロセス",
                        "id": "Q14",
                        "title": "Q14. プロセスを守る人と破る人",
                        "content": [
                            "ルールを厳密に守る人と、柔軟に破る人が混在している。どちらを是とするか。",
                            "",
                            "意図:",
                            "プロセスを目的ではなく制約として扱えるか。"
                        ]
                    },
                    {
                        "section": "5. プロセス",
                        "id": "Q18",
                        "title": "Q18. プロセスが増えすぎたとき",
                        "content": [
                            "品質を守るためにプロセスが増え、現場の負担が明確に増している。どの基準で削るか。",
                            "",
                            "意図:",
                            "プロセスを削る判断ができるか。"
                        ]
                    }
                ],
                "6. トレードオフ": [
                    {
                        "section": "6. トレードオフ",
                        "id": "Q7",
                        "title": "Q7. 品質とスピードのトレードオフ",
                        "content": [
                            "重要顧客向けの機能リリースが迫っているが、現状の品質ではリスクが高いと判断される。リリース延期以外に、PMが取り得る選択肢は何か。",
                            "",
                            "意図:",
                            "トレードオフを多段階で考えられるか。"
                        ]
                    },
                    {
                        "section": "6. トレードオフ",
                        "id": "Q13",
                        "title": "Q13. 品質改善がスピードを落とすとき",
                        "content": [
                            "品質向上施策により、明確にスピードが落ち始めた。この状態をどう判断し、どう調整するか。",
                            "",
                            "意図:",
                            "品質とスピードを対立概念にしない。"
                        ]
                    }
                ],
                "7. 属人化・構造": [
                    {
                        "section": "7. 属人化・構造",
                        "id": "Q8",
                        "title": "Q8. 属人化と品質",
                        "content": [
                            "特定メンバーが抜けると、品質が急激に落ちる構造になっている。この問題を品質の問題として扱うか、プロセスの問題として扱うか。また、最初の一手は何か。",
                            "",
                            "意図:",
                            "人の問題を構造の問題に変換できるか。"
                        ]
                    },
                    {
                        "section": "7. 属人化・構造",
                        "id": "Q15",
                        "title": "Q15. レビューが属人化している",
                        "content": [
                            "特定の人のレビューだけが品質を担保している。この状態をどう評価し、どう是正するか。",
                            "",
                            "意図:",
                            "ヒーロー依存を構造の問題として見られるか。"
                        ]
                    }
                ],
                "8. 文化・空気": [
                    {
                        "section": "8. 文化・空気",
                        "id": "Q11",
                        "title": "Q11. 不具合が「慣れ」始めたとき",
                        "content": [
                            "軽微な不具合が常態化し、誰も強く問題視しなくなっている。PMとして、この状態をどう評価し、どう介入するか。",
                            "",
                            "意図:",
                            "劣化を文化として捉えられるか。"
                        ]
                    }
                ],
                "9. 改善・学習": [
                    {
                        "section": "9. 改善・学習",
                        "id": "Q16",
                        "title": "Q16. 再発防止が形だけになったとき",
                        "content": [
                            "再発防止策は毎回書かれているが、効果が見えない。どこに問題があると考えるか。",
                            "",
                            "意図:",
                            "再発防止を手続きではなく学習として扱えるか。"
                        ]
                    },
                    {
                        "section": "9. 改善・学習",
                        "id": "Q17",
                        "title": "Q17. 品質改善の効果が見えない",
                        "content": [
                            "改善施策を打っているが、良くなっている実感も悪化している実感もない。この状態をどう判断するか。",
                            "",
                            "意図:",
                            "改善を可視化できないリスクの理解。"
                        ]
                    }
                ]
            };

            // 選択されたタイプのデータを使用
            let quizData = awsQuizData;
            if (quizType === 'pm') quizData = pmQuizData;
            if (quizType === 'quality') quizData = qualityQuizData;

            // セクションごとに表示
            Object.keys(quizData).sort().forEach(section => {
                const sectionBox = h("div", { class: "card p col", style: { gap: '12px' } });
                sectionBox.appendChild(h("div", { class: "h3", text: section }));

                const questions = quizData[section];
                questions.forEach((q, idx) => {
                    const qBox = h("div", { class: "col", style: { gap: '8px', padding: '12px 0', borderBottom: '1px solid var(--border)' } });
                    qBox.appendChild(h("div", { class: "row", style: { gap: '8px', alignItems: 'center' } },
                        h("span", { class: "badge", text: q.id }),
                        h("div", { style: { fontWeight: '600' }, text: q.title.replace(q.id + '. ', '') })
                    ));

                    q.content.forEach(line => {
                        if (line.trim()) {
                            qBox.appendChild(h("div", { class: "muted", style: { whiteSpace: 'pre-wrap', lineHeight: '1.6' }, text: line }));
                        }
                    });

                    sectionBox.appendChild(qBox);
                });

                box.appendChild(sectionBox);
            });

            // Contact form section
            const contactBox = h("div", { class: "card p col", style: { gap: '14px', marginTop: '24px' } });
            contactBox.appendChild(h("div", { class: "h3", text: "模範解答について" }));
            contactBox.appendChild(h("div", { class: "muted" }, "模範解答をご希望の方は、以下のフォームからお気軽にご連絡ください。"));

            const nameInput = h("input", { class: "input", type: "text", placeholder: "お名前" });
            const emailInput = h("input", { class: "input", type: "email", placeholder: "メールアドレス" });
            const messageInput = h("textarea", { class: "input", rows: 4, placeholder: "メッセージ（任意）", style: { resize: 'vertical' } });

            const submitBtn = h("button", {
                class: "btn",
                onClick: () => {
                    const name = nameInput.value.trim();
                    const email = emailInput.value.trim();
                    const message = messageInput.value.trim();

                    if (!name || !email) {
                        toast("お名前とメールアドレスを入力してください", "error");
                        return;
                    }

                    const subject = encodeURIComponent(`${pageTitle}の模範解答について`);
                    const body = encodeURIComponent(
                        `お名前: ${name}\nメールアドレス: ${email}\n\nメッセージ:\n${message || "(なし)"}`
                    );
                    location.href = `mailto:${store.profile.email}?subject=${subject}&body=${body}`;
                }
            }, "送信");

            contactBox.appendChild(h("div", { class: "col", style: { gap: '10px' } },
                h("div", { class: "col", style: { gap: '4px' } }, h("div", { class: "mini", text: "お名前 *" }), nameInput),
                h("div", { class: "col", style: { gap: '4px' } }, h("div", { class: "mini", text: "メールアドレス *" }), emailInput),
                h("div", { class: "col", style: { gap: '4px' } }, h("div", { class: "mini", text: "メッセージ" }), messageInput),
                submitBtn
            ));

            box.appendChild(contactBox);

            return box;
        }

        function FatalPage(error) {
            const msg = (error && error.message) ? error.message : String(error || 'Unknown error');
            const stack = (error && error.stack) ? String(error.stack) : '';

            function clearAllData() {
                if (!confirm('LocalStorageのデータを削除して再読み込みしますか？')) return;
                try {
                    localStorage.removeItem(CONSTANTS.STORAGE_KEY);
                    localStorage.removeItem(CONSTANTS.SNAPSHOT_KEY);
                } catch { }
                location.reload();
            }

            return h('div', { class: 'flex flex-col gap-4 max-w-2xl' },
                h('h1', { class: 'h1' }, '致命的エラーが発生しました'),
                h('p', { class: 'text-muted' }, '表示を継続できない例外が発生しました。下の情報を確認し、必要ならデータを初期化してください。'),
                h('section', { class: 'card' },
                    h('div', { class: 'card-body' },
                        h('div', { class: 'h3 mb-2' }, 'エラー'),
                        h('pre', { style: { whiteSpace: 'pre-wrap', wordBreak: 'break-word' } }, msg),
                        stack ? h('details', { class: 'mt-3' },
                            h('summary', { class: 'cursor-pointer text-sm' }, 'スタックトレース'),
                            h('pre', { class: 'text-sm', style: { whiteSpace: 'pre-wrap', wordBreak: 'break-word', marginTop: '8px' } }, stack)
                        ) : null
                    )
                ),
                h('div', { class: 'flex flex-wrap gap-2' },
                    h('button', { class: 'btn btn-secondary', onclick: () => { window.__fatalError = null; Router.navigate(''); } }, 'ホームへ'),
                    h('button', { class: 'btn btn-danger', onclick: clearAllData }, 'データを削除して再起動')
                )
            );
        }

        function NotFoundPage() {
            return h('article', { class: 'flex flex-col gap-6 max-w-2xl' },
                h('header', {}, h('h1', { class: 'h1' }, 'Not Found')),
                h('p', { class: 'text-muted' }, '指定されたページは見つかりません。'),
                h('div', { class: 'flex gap-3' },
                    h('button', { class: 'btn btn-secondary', onclick: () => Router.navigate('') }, 'ホームへ'),
                    h('button', { class: 'btn btn-ghost', onclick: () => Router.navigate('projects') }, 'プロジェクト一覧へ')
                )
            );
        }

        // ===== Main Renderer =====
        function render() {
            const route = Router.getRoute();
            const content = document.getElementById('content');
            const sidebarEl = document.getElementById('sidebar');

            // Update sidebar
            if (sidebarEl) {
                clear(sidebarEl);
                sidebarEl.appendChild(Sidebar(false));
            }

            // Render page content
            clear(content);

            let page;
            const fatal = window.__fatalError;
            if (fatal) {
                page = FatalPage(fatal);
            } else {
                try {
                    switch (route.name) {
                        case 'home':
                            page = HomePage();
                            break;
                        case 'projects':
                            page = ProjectsPage();
                            break;
                        case 'project-detail':
                            page = ProjectDetailPage(route.params.slug);
                            break;
                        case 'apps':
                            page = AppsPage();
                            break;
                        case 'app-task':
                            page = TaskPage();
                            break;
                        case 'app-todo':
                            page = TodoPage();
                            break;
                        case 'app-pomodoro':
                            page = PomodoroPage();
                            break;
                        case 'app-ai':
                            page = AIPage();
                            break;
                        case 'settings':
                            page = SettingsPage();
                            break;
                        case 'about':
                            page = AboutPage();
                            break;
                        case 'resume':
                            page = ResumePage();
                            break;
                        case 'contact':
                            page = ContactPage();
                            break;
                        case 'quiz':
                            page = QuizPage();
                            break;
                        case 'not-found':
                        default:
                            page = NotFoundPage();
                    }


                } catch (e) {
                    window.__fatalError = e;
                    page = FatalPage(e);
                }
            }

            if (page) {
                content.appendChild(page);
            }
            // Update SEO
            SEO.update(route);

            // Sync mobile drawer state
            syncMobileDrawer();
        }

        // ===== Mobile Drawer =====
        function syncMobileDrawer() {
            const isMobile = window.matchMedia('(max-width: 920px)').matches;
            const topbar = document.getElementById('topbar');

            if (topbar) {
                topbar.style.display = isMobile ? 'flex' : 'none';
            }
        }

        function openDrawer() {
            const drawer = document.getElementById('drawer');
            const overlay = document.getElementById('overlay');

            clear(drawer);
            drawer.appendChild(Sidebar(true));
            drawer.style.display = 'block';
            overlay.style.display = 'block';

            // Update ARIA
            drawer.setAttribute('aria-hidden', 'false');
            overlay.setAttribute('aria-hidden', 'false');
            document.getElementById('menuBtn').setAttribute('aria-expanded', 'true');

            // Focus management
            drawer.querySelector('button, a, input, select, textarea')?.focus();
        }

        function closeDrawer() {
            const drawer = document.getElementById('drawer');
            const overlay = document.getElementById('overlay');

            drawer.style.display = 'none';
            overlay.style.display = 'none';

            drawer.setAttribute('aria-hidden', 'true');
            overlay.setAttribute('aria-hidden', 'true');
            document.getElementById('menuBtn').setAttribute('aria-expanded', 'false');
        }


        // ===== Fatal overlay (global error capture) =====
        window.__fatalError = null;
        window.addEventListener('error', (ev) => {
            try {
                const err = ev && ev.error ? ev.error : new Error(ev && ev.message ? String(ev.message) : 'Unknown error');
                window.__fatalError = err;
            } catch (e) {
                window.__fatalError = e;
            }
            try { render(); } catch { }
        });

        window.addEventListener('unhandledrejection', (ev) => {
            try {
                const reason = ev && ev.reason ? ev.reason : new Error('Unhandled rejection');
                const err = reason instanceof Error ? reason : new Error(typeof reason === 'string' ? reason : JSON.stringify(reason));
                window.__fatalError = err;
            } catch (e) {
                window.__fatalError = e;
            }
            try { render(); } catch { }
        });

        // ===== Event Listeners =====
        function init() {
            // Theme
            Theme.init();

            // Mobile menu
            document.getElementById('menuBtn')?.addEventListener('click', openDrawer);
            document.getElementById('overlay')?.addEventListener('click', closeDrawer);
            document.getElementById('themeBtnTop')?.addEventListener('click', Theme.cycle);

            // Escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    closeDrawer();
                }
            });

            // Router
            Router.subscribe(render);

            // State changes
            State.subscribe(() => render());

            // Initial render
            render();

            // Service Worker registration (optional enhancement)
            try {
                if ('serviceWorker' in navigator) {
                    navigator.serviceWorker.register('data:text/javascript,' + encodeURIComponent(`
                        self.addEventListener('install', e => self.skipWaiting());
                        self.addEventListener('activate', e => e.waitUntil(self.clients.claim()));
                        self.addEventListener('fetch', e => e.respondWith(fetch(e.request).catch(() => new Response('Offline'))));
                    `)).catch(() => { });
                }
            } catch (e) {
                console.warn('Service Worker access denied:', e);
            }

            console.log('Portfolio SPA initialized');
        }

        // ===== Initialization =====
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }

    </script>
</body>

</html>
